<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android 开发必备工具合集</title>
    <url>/2018/05/09/android-tools/</url>
    <content><![CDATA[<p>工欲善其事必先利其器</p>
<a id="more"></a>

<h2 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h2><p>MAC 包管理工具<br>官网：<a href="https://brew.sh/">https://brew.sh/</a></p>
<h2 id="Homebrew-Cask"><a href="#Homebrew-Cask" class="headerlink" title="Homebrew-Cask"></a>Homebrew-Cask</h2><p>MAC APP 管理工具<br>官网：<a href="http://caskroom.github.io/">http://caskroom.github.io/</a></p>
<h2 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h2><p>替代系统 Terminal，集成 tmux 以原生方式分屏，支持自定义快捷键等…<br>官网：<a href="https://www.iterm2.com/">https://www.iterm2.com/</a></p>
<h2 id="Oh-My-ZSH"><a href="#Oh-My-ZSH" class="headerlink" title="Oh My ZSH"></a>Oh My ZSH</h2><p>配合 iTerm2 个性化显示效果，非常炫酷，同时支持更多 zsh 插件，如autojump、git、extract、sublime、z等。<br>官网：<a href="http://ohmyz.sh/">http://ohmyz.sh/</a><br>官方插件一览：<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins-Overview">https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins-Overview</a></p>
<h2 id="Snap"><a href="#Snap" class="headerlink" title="Snap"></a>Snap</h2><p>为 App 添加全局快捷键，快速打开或切换 App<br>App Store：<a href="https://itunes.apple.com/cn/app/snap/id418073146?l=en&amp;mt=12">https://itunes.apple.com/cn/app/snap/id418073146?l=en&amp;mt=12</a></p>
<h2 id="Color-Note"><a href="#Color-Note" class="headerlink" title="Color Note"></a>Color Note</h2><p>屏幕取色软件<br>App Store：<a href="https://itunes.apple.com/cn/app/color-note/id1099028591?l=en&amp;mt=12">https://itunes.apple.com/cn/app/color-note/id1099028591?l=en&amp;mt=12</a></p>
<h2 id="Cornerstone"><a href="#Cornerstone" class="headerlink" title="Cornerstone"></a>Cornerstone</h2><p>比较好用的 SVN 管理软件。<br>收费软件 ~ 自行 Google</p>
<h2 id="ImageOptim"><a href="#ImageOptim" class="headerlink" title="ImageOptim"></a>ImageOptim</h2><p>一款图片无损压缩软件，简单实用。<br>官网：<a href="https://imageoptim.com/mac">https://imageoptim.com/mac</a></p>
<h2 id="PostMan"><a href="#PostMan" class="headerlink" title="PostMan"></a>PostMan</h2><p>接口调试必备。<br>官网：<a href="https://www.getpostman.com/">https://www.getpostman.com/</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>tools</tag>
        <tag>buildtime</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-studio plugins</title>
    <url>/2018/05/09/android-studio-plugin/</url>
    <content><![CDATA[<p>工欲善其事必先利其器</p>
<a id="more"></a>
<h2 id="必备"><a href="#必备" class="headerlink" title="必备"></a>必备</h2><p>ADB idea<br>Adds the following ADB commands to Android Studio and Intellij.<br>方便快捷执行 ADB 常用命令</p>
<p>Gradle Killer<br>This plugin kills Gradle tasks using the system task manager with just one click. No more struggling with “ps” or playing Russian roulette with “java.exe” processes! Just click the icon in the “Run” section and you’re done!<br>在Gradle执行期间强制终止Gradle运行</p>
<h2 id="Java相关"><a href="#Java相关" class="headerlink" title="Java相关"></a>Java相关</h2><p>Alibaba Java Coding Guidelines<br>Alibaba Java Coding Guidelines plugin support.<br>Github：<a href="https://github.com/alibaba/p3c">https://github.com/alibaba/p3c</a><br>Java手册：PDF</p>
<p>Android Parcelable code generator<br>Plugin which generates Android Parcelable boilerplate code for you.</p>
<p>GsonFormat<br>quickly to convert a JSON string to an InnerClassEntity class.</p>
<h2 id="Kotlin相关"><a href="#Kotlin相关" class="headerlink" title="Kotlin相关"></a>Kotlin相关</h2><p>Parcelable Code Generator(for kotlin)<br>Parcelable Code Generator is a plugin which generates Android Parcelable boilerplate code for kotlin class.</p>
<p>Json to Kotlin Class(JsonToKotlinClass)<br>Plugin for Kotlin to convert Json String into Kotlin data class code quickly</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>tools</tag>
        <tag>buildtime</tag>
        <tag>android-studio</tag>
      </tags>
  </entry>
  <entry>
    <title>NPM 淘宝镜像（CNPM）</title>
    <url>/2018/05/28/cnpm/</url>
    <content><![CDATA[<p>NPM 淘宝镜像（CNPM）</p>
<a id="more"></a>

<p>$ npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p>
<p>或者你直接通过添加 npm 参数 alias 一个新命令:<br>alias cnpm=”npm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> <br>–cache=$HOME/.npm/.cache/cnpm <br>–disturl=<a href="https://npm.taobao.org/dist">https://npm.taobao.org/dist</a> <br>–userconfig=$HOME/.cnpmrc”</p>
<p>Nodemon<br>开发调试工具<br>npm install -g nodemon<br>使用时候只需要执行命令 nodemon 运行 server , 每次改动都会触发 node 服务重启</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>taobao</tag>
      </tags>
  </entry>
  <entry>
    <title>interview/android</title>
    <url>/2020/10/10/interview-android/</url>
    <content><![CDATA[<h3 id="一、Android基础知识点"><a href="#一、Android基础知识点" class="headerlink" title="一、Android基础知识点"></a>一、Android基础知识点</h3><h2 id="四大组件是什么"><a href="#四大组件是什么" class="headerlink" title="四大组件是什么"></a>四大组件是什么</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Activity</span><br><span class="line">Service</span><br><span class="line">Broadcast Receiver</span><br><span class="line">Content Provider</span><br></pre></td></tr></table></figure>
<h2 id="四大组件的生命周期和简单用法"><a href="#四大组件的生命周期和简单用法" class="headerlink" title="四大组件的生命周期和简单用法"></a>四大组件的生命周期和简单用法</h2><blockquote>
<p>Activity</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">oncreate &#x3D;&gt; onRestart &#x3D;&gt; onStart &#x3D;&gt; onResume &#x3D;&gt; onPause &#x3D;&gt; onStop &#x3D;&gt; onDestory</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Service</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">startService() &#x3D;&gt; onCreate &#x3D;&gt; onStartCommand &#x3D;&gt; onDestory</span><br><span class="line">bindService() &#x3D;&gt; onCreate &#x3D;&gt; onBind(onRebind) &#x3D;&gt; onUnbind &#x3D;&gt; onDestory</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Broadcast Receiver</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registerReceiver(manifest or intent 显示注册) &#x3D;&gt; onReceive &#x3D;&gt; unRegisterReceiver（仅适用于intent显示注册）</span><br></pre></td></tr></table></figure>
<p>请注意注册和注销接收器的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">比方说，如果您使用 Activity 上下文在 onCreate(Bundle) 中注册接收器，则应在 onDestroy() 中注销，以防接收器从 Activity 上下文中泄露出去。如果您在 onResume() 中注册接收器，则应在 onPause() 中注销，以防多次注册接收器（如果您不想在暂停时接收广播，这样可以减少不必要的系统开销）。请勿在 onSaveInstanceState(Bundle) 中注销，因为如果用户在历史记录堆栈中后退，则不会调用此方法。</span><br></pre></td></tr></table></figure>
<p>发送方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sendOrderedBroadcast(Intent, String)</span><br><span class="line">sendBroadcast(Intent)</span><br><span class="line">LocalBroadcastManager.sendBroadcast</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Content Provider</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UI &#x3D;&gt; CursorLoader &#x3D;&gt; ContentResolver(.query) &#x3D;&gt; ContentProvider &#x3D;&gt; Data</span><br></pre></td></tr></table></figure>

<h2 id="Activity之间的通信方式"><a href="#Activity之间的通信方式" class="headerlink" title="Activity之间的通信方式"></a>Activity之间的通信方式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Intent</span><br><span class="line">startActivityForResult &#x3D;&gt; onActivityResult</span><br><span class="line">By file</span><br><span class="line">single instacne</span><br><span class="line">static variable</span><br><span class="line">service</span><br></pre></td></tr></table></figure>
<h2 id="Activity各种情况下的生命周期"><a href="#Activity各种情况下的生命周期" class="headerlink" title="Activity各种情况下的生命周期"></a>Activity各种情况下的生命周期</h2><h2 id="横竖屏切换的时候，Activity-各种情况下的生命周期"><a href="#横竖屏切换的时候，Activity-各种情况下的生命周期" class="headerlink" title="横竖屏切换的时候，Activity 各种情况下的生命周期"></a>横竖屏切换的时候，Activity 各种情况下的生命周期</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:configChanges&#x3D;&quot;default&quot;</span><br><span class="line">android:configChanges&#x3D;&quot;orientation&quot;</span><br><span class="line">onPause--onSaveInstanceState--onStop--onCreate()--onStart()--onResume()</span><br><span class="line"></span><br><span class="line">android:configChanges&#x3D;&quot;orientation|keyboardHidden&quot;</span><br><span class="line">android:configChanges&#x3D;&quot;orientation|keyboardHidden|screenSize&quot; Android 3.2（API 级别 13）及以上版本</span><br><span class="line">onConfigurationChanged</span><br></pre></td></tr></table></figure>
<h2 id="Activity与Fragment之间生命周期比较"><a href="#Activity与Fragment之间生命周期比较" class="headerlink" title="Activity与Fragment之间生命周期比较"></a>Activity与Fragment之间生命周期比较</h2><h2 id="Activity上有Dialog的时候按Home键时的生命周期"><a href="#Activity上有Dialog的时候按Home键时的生命周期" class="headerlink" title="Activity上有Dialog的时候按Home键时的生命周期"></a>Activity上有Dialog的时候按Home键时的生命周期</h2><h2 id="两个Activity-之间跳转时必然会执行的是哪几个方法？"><a href="#两个Activity-之间跳转时必然会执行的是哪几个方法？" class="headerlink" title="两个Activity 之间跳转时必然会执行的是哪几个方法？"></a>两个Activity 之间跳转时必然会执行的是哪几个方法？</h2><h2 id="前台切换到后台，然后再回到前台，Activity生命周期回调方法。弹出Dialog，生命值周期回调方法。"><a href="#前台切换到后台，然后再回到前台，Activity生命周期回调方法。弹出Dialog，生命值周期回调方法。" class="headerlink" title="前台切换到后台，然后再回到前台，Activity生命周期回调方法。弹出Dialog，生命值周期回调方法。"></a>前台切换到后台，然后再回到前台，Activity生命周期回调方法。弹出Dialog，生命值周期回调方法。</h2><h2 id="Activity的四种启动模式对比"><a href="#Activity的四种启动模式对比" class="headerlink" title="Activity的四种启动模式对比"></a>Activity的四种启动模式对比</h2><h2 id="Activity状态保存于恢复"><a href="#Activity状态保存于恢复" class="headerlink" title="Activity状态保存于恢复"></a>Activity状态保存于恢复</h2><h2 id="fragment各种情况下的生命周期"><a href="#fragment各种情况下的生命周期" class="headerlink" title="fragment各种情况下的生命周期"></a>fragment各种情况下的生命周期</h2><h2 id="Fragment状态保存startActivityForResult是哪个类的方法，在什么情况下使用？"><a href="#Fragment状态保存startActivityForResult是哪个类的方法，在什么情况下使用？" class="headerlink" title="Fragment状态保存startActivityForResult是哪个类的方法，在什么情况下使用？"></a>Fragment状态保存startActivityForResult是哪个类的方法，在什么情况下使用？</h2><h2 id="如何实现Fragment的滑动？"><a href="#如何实现Fragment的滑动？" class="headerlink" title="如何实现Fragment的滑动？"></a>如何实现Fragment的滑动？</h2><h2 id="fragment之间传递数据的方式？"><a href="#fragment之间传递数据的方式？" class="headerlink" title="fragment之间传递数据的方式？"></a>fragment之间传递数据的方式？</h2><h2 id="Activity-怎么和Service-绑定？"><a href="#Activity-怎么和Service-绑定？" class="headerlink" title="Activity 怎么和Service 绑定？"></a>Activity 怎么和Service 绑定？</h2><h2 id="怎么在Activity-中启动自己对应的Service？"><a href="#怎么在Activity-中启动自己对应的Service？" class="headerlink" title="怎么在Activity 中启动自己对应的Service？"></a>怎么在Activity 中启动自己对应的Service？</h2><h2 id="service和activity怎么进行数据交互？"><a href="#service和activity怎么进行数据交互？" class="headerlink" title="service和activity怎么进行数据交互？"></a>service和activity怎么进行数据交互？</h2><h2 id="Service的开启方式"><a href="#Service的开启方式" class="headerlink" title="Service的开启方式"></a>Service的开启方式</h2><h2 id="请描述一下Service-的生命周期"><a href="#请描述一下Service-的生命周期" class="headerlink" title="请描述一下Service 的生命周期"></a>请描述一下Service 的生命周期</h2><h2 id="谈谈你对ContentProvider的理解"><a href="#谈谈你对ContentProvider的理解" class="headerlink" title="谈谈你对ContentProvider的理解"></a>谈谈你对ContentProvider的理解</h2><h2 id="说说ContentProvider、ContentResolver、ContentObserver-之间的关系"><a href="#说说ContentProvider、ContentResolver、ContentObserver-之间的关系" class="headerlink" title="说说ContentProvider、ContentResolver、ContentObserver 之间的关系"></a>说说ContentProvider、ContentResolver、ContentObserver 之间的关系</h2><h2 id="请描述一下广播BroadcastReceiver的理解"><a href="#请描述一下广播BroadcastReceiver的理解" class="headerlink" title="请描述一下广播BroadcastReceiver的理解"></a>请描述一下广播BroadcastReceiver的理解</h2><h2 id="广播的分类"><a href="#广播的分类" class="headerlink" title="广播的分类"></a>广播的分类</h2><h2 id="广播使用的方式和场景"><a href="#广播使用的方式和场景" class="headerlink" title="广播使用的方式和场景"></a>广播使用的方式和场景</h2><h2 id="在manifest-和代码中如何注册和使用BroadcastReceiver"><a href="#在manifest-和代码中如何注册和使用BroadcastReceiver" class="headerlink" title="在manifest 和代码中如何注册和使用BroadcastReceiver?"></a>在manifest 和代码中如何注册和使用BroadcastReceiver?</h2><h2 id="本地广播和全局广播有什么差别？"><a href="#本地广播和全局广播有什么差别？" class="headerlink" title="本地广播和全局广播有什么差别？"></a>本地广播和全局广播有什么差别？</h2><h2 id="BroadcastReceiver，LocalBroadcastReceiver-区别"><a href="#BroadcastReceiver，LocalBroadcastReceiver-区别" class="headerlink" title="BroadcastReceiver，LocalBroadcastReceiver 区别"></a>BroadcastReceiver，LocalBroadcastReceiver 区别</h2><h2 id="AlertDialog-popupWindow-Activity区别"><a href="#AlertDialog-popupWindow-Activity区别" class="headerlink" title="AlertDialog,popupWindow,Activity区别"></a>AlertDialog,popupWindow,Activity区别</h2><h2 id="Application-和-Activity-的-Context-对象的区别"><a href="#Application-和-Activity-的-Context-对象的区别" class="headerlink" title="Application 和 Activity 的 Context 对象的区别"></a>Application 和 Activity 的 Context 对象的区别</h2><h2 id="Android属性动画特性"><a href="#Android属性动画特性" class="headerlink" title="Android属性动画特性"></a>Android属性动画特性</h2><h2 id="如何导入外部数据库"><a href="#如何导入外部数据库" class="headerlink" title="如何导入外部数据库?"></a>如何导入外部数据库?</h2><h2 id="LinearLayout、RelativeLayout、FrameLayout的特性及对比，并介绍使用场景。"><a href="#LinearLayout、RelativeLayout、FrameLayout的特性及对比，并介绍使用场景。" class="headerlink" title="LinearLayout、RelativeLayout、FrameLayout的特性及对比，并介绍使用场景。"></a>LinearLayout、RelativeLayout、FrameLayout的特性及对比，并介绍使用场景。</h2><h2 id="谈谈对接口与回调的理解"><a href="#谈谈对接口与回调的理解" class="headerlink" title="谈谈对接口与回调的理解"></a>谈谈对接口与回调的理解</h2><h2 id="回调的原理"><a href="#回调的原理" class="headerlink" title="回调的原理"></a>回调的原理</h2><h2 id="写一个回调demo"><a href="#写一个回调demo" class="headerlink" title="写一个回调demo"></a>写一个回调demo</h2><h2 id="介绍下SurfView"><a href="#介绍下SurfView" class="headerlink" title="介绍下SurfView"></a>介绍下SurfView</h2><h2 id="RecycleView的使用"><a href="#RecycleView的使用" class="headerlink" title="RecycleView的使用"></a>RecycleView的使用</h2><h2 id="序列化的作用，以及Android两种序列化的区别"><a href="#序列化的作用，以及Android两种序列化的区别" class="headerlink" title="序列化的作用，以及Android两种序列化的区别"></a>序列化的作用，以及Android两种序列化的区别</h2><h2 id="差值器"><a href="#差值器" class="headerlink" title="差值器"></a>差值器</h2><h2 id="估值器"><a href="#估值器" class="headerlink" title="估值器"></a>估值器</h2><h2 id="Android中数据存储方式"><a href="#Android中数据存储方式" class="headerlink" title="Android中数据存储方式"></a>Android中数据存储方式</h2><h1 id="二、Android源码相关分析"><a href="#二、Android源码相关分析" class="headerlink" title="二、Android源码相关分析"></a>二、Android源码相关分析</h1><h2 id="Android动画框架实现原理"><a href="#Android动画框架实现原理" class="headerlink" title="Android动画框架实现原理"></a>Android动画框架实现原理</h2><h2 id="Android各个版本API的区别"><a href="#Android各个版本API的区别" class="headerlink" title="Android各个版本API的区别"></a>Android各个版本API的区别</h2><h2 id="Requestlayout，onlayout，onDraw，DrawChild区别与联系"><a href="#Requestlayout，onlayout，onDraw，DrawChild区别与联系" class="headerlink" title="Requestlayout，onlayout，onDraw，DrawChild区别与联系"></a>Requestlayout，onlayout，onDraw，DrawChild区别与联系</h2><h2 id="invalidate和postInvalidate的区别及使用"><a href="#invalidate和postInvalidate的区别及使用" class="headerlink" title="invalidate和postInvalidate的区别及使用"></a>invalidate和postInvalidate的区别及使用</h2><h2 id="Activity-Window-View三者的差别"><a href="#Activity-Window-View三者的差别" class="headerlink" title="Activity-Window-View三者的差别"></a>Activity-Window-View三者的差别</h2><h2 id="谈谈对Volley的理解"><a href="#谈谈对Volley的理解" class="headerlink" title="谈谈对Volley的理解"></a>谈谈对Volley的理解</h2><h2 id="如何优化自定义View"><a href="#如何优化自定义View" class="headerlink" title="如何优化自定义View"></a>如何优化自定义View</h2><h2 id="低版本SDK如何实现高版本api？"><a href="#低版本SDK如何实现高版本api？" class="headerlink" title="低版本SDK如何实现高版本api？"></a>低版本SDK如何实现高版本api？</h2><h2 id="描述一次网络请求的流程"><a href="#描述一次网络请求的流程" class="headerlink" title="描述一次网络请求的流程"></a>描述一次网络请求的流程</h2><h2 id="HttpUrlConnection-和-okhttp关系"><a href="#HttpUrlConnection-和-okhttp关系" class="headerlink" title="HttpUrlConnection 和 okhttp关系"></a>HttpUrlConnection 和 okhttp关系</h2><h2 id="Bitmap对象的理解"><a href="#Bitmap对象的理解" class="headerlink" title="Bitmap对象的理解"></a>Bitmap对象的理解</h2><h2 id="looper架构"><a href="#looper架构" class="headerlink" title="looper架构"></a>looper架构</h2><h2 id="ActivityThread，AMS，WMS的工作原理"><a href="#ActivityThread，AMS，WMS的工作原理" class="headerlink" title="ActivityThread，AMS，WMS的工作原理"></a>ActivityThread，AMS，WMS的工作原理</h2><h2 id="自定义View如何考虑机型适配"><a href="#自定义View如何考虑机型适配" class="headerlink" title="自定义View如何考虑机型适配"></a>自定义View如何考虑机型适配</h2><h2 id="自定义View的事件"><a href="#自定义View的事件" class="headerlink" title="自定义View的事件"></a>自定义View的事件</h2><h2 id="AstncTask-HttpClient-与-AsyncHttpClient有什么区别？"><a href="#AstncTask-HttpClient-与-AsyncHttpClient有什么区别？" class="headerlink" title="AstncTask+HttpClient 与 AsyncHttpClient有什么区别？"></a>AstncTask+HttpClient 与 AsyncHttpClient有什么区别？</h2><h2 id="LaunchMode应用场景"><a href="#LaunchMode应用场景" class="headerlink" title="LaunchMode应用场景"></a>LaunchMode应用场景</h2><h2 id="AsyncTask-如何使用"><a href="#AsyncTask-如何使用" class="headerlink" title="AsyncTask 如何使用?"></a>AsyncTask 如何使用?</h2><h2 id="SpareArray原理"><a href="#SpareArray原理" class="headerlink" title="SpareArray原理"></a>SpareArray原理</h2><h2 id="请介绍下ContentProvider-是如何实现数据共享的？"><a href="#请介绍下ContentProvider-是如何实现数据共享的？" class="headerlink" title="请介绍下ContentProvider 是如何实现数据共享的？"></a>请介绍下ContentProvider 是如何实现数据共享的？</h2><h2 id="AndroidService与Activity之间通信的几种方式"><a href="#AndroidService与Activity之间通信的几种方式" class="headerlink" title="AndroidService与Activity之间通信的几种方式"></a>AndroidService与Activity之间通信的几种方式</h2><h2 id="IntentService原理及作用是什么？"><a href="#IntentService原理及作用是什么？" class="headerlink" title="IntentService原理及作用是什么？"></a>IntentService原理及作用是什么？</h2><h2 id="说说Activity、Intent、Service-是什么关系"><a href="#说说Activity、Intent、Service-是什么关系" class="headerlink" title="说说Activity、Intent、Service 是什么关系"></a>说说Activity、Intent、Service 是什么关系</h2><h2 id="ApplicationContext和ActivityContext的区别"><a href="#ApplicationContext和ActivityContext的区别" class="headerlink" title="ApplicationContext和ActivityContext的区别"></a>ApplicationContext和ActivityContext的区别</h2><h2 id="SP是进程同步的吗-有什么方法做到同步？"><a href="#SP是进程同步的吗-有什么方法做到同步？" class="headerlink" title="SP是进程同步的吗?有什么方法做到同步？"></a>SP是进程同步的吗?有什么方法做到同步？</h2><h2 id="谈谈多线程在Android中的使用"><a href="#谈谈多线程在Android中的使用" class="headerlink" title="谈谈多线程在Android中的使用"></a>谈谈多线程在Android中的使用</h2><h2 id="进程和-Application-的生命周期"><a href="#进程和-Application-的生命周期" class="headerlink" title="进程和 Application 的生命周期"></a>进程和 Application 的生命周期</h2><h2 id="封装View的时候怎么知道view的大小"><a href="#封装View的时候怎么知道view的大小" class="headerlink" title="封装View的时候怎么知道view的大小"></a>封装View的时候怎么知道view的大小</h2><h2 id="RecycleView原理"><a href="#RecycleView原理" class="headerlink" title="RecycleView原理"></a>RecycleView原理</h2><h2 id="AndroidManifest的作用与理解"><a href="#AndroidManifest的作用与理解" class="headerlink" title="AndroidManifest的作用与理解"></a>AndroidManifest的作用与理解</h2><h1 id="三、常见的一些原理性问题"><a href="#三、常见的一些原理性问题" class="headerlink" title="三、常见的一些原理性问题"></a>三、常见的一些原理性问题</h1><h3 id="Handler机制和底层实现"><a href="#Handler机制和底层实现" class="headerlink" title="Handler机制和底层实现"></a>Handler机制和底层实现</h3><h3 id="Handler、Thread和HandlerThread的差别"><a href="#Handler、Thread和HandlerThread的差别" class="headerlink" title="Handler、Thread和HandlerThread的差别"></a>Handler、Thread和HandlerThread的差别</h3><h3 id="handler发消息给子线程，looper怎么启动？"><a href="#handler发消息给子线程，looper怎么启动？" class="headerlink" title="handler发消息给子线程，looper怎么启动？"></a>handler发消息给子线程，looper怎么启动？</h3><h3 id="关于Handler，在任何地方new-Handler-都是什么线程下"><a href="#关于Handler，在任何地方new-Handler-都是什么线程下" class="headerlink" title="关于Handler，在任何地方new Handler 都是什么线程下?"></a>关于Handler，在任何地方new Handler 都是什么线程下?</h3><h3 id="ThreadLocal原理，实现及如何保证Local属性？"><a href="#ThreadLocal原理，实现及如何保证Local属性？" class="headerlink" title="ThreadLocal原理，实现及如何保证Local属性？"></a>ThreadLocal原理，实现及如何保证Local属性？</h3><h3 id="请解释下在单线程模型中Message、Handler、Message-Queue、Looper之间的关系"><a href="#请解释下在单线程模型中Message、Handler、Message-Queue、Looper之间的关系" class="headerlink" title="请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系"></a>请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系</h3><h3 id="请描述一下View事件传递分发机制"><a href="#请描述一下View事件传递分发机制" class="headerlink" title="请描述一下View事件传递分发机制"></a>请描述一下View事件传递分发机制</h3><h3 id="Touch事件传递流程"><a href="#Touch事件传递流程" class="headerlink" title="Touch事件传递流程"></a>Touch事件传递流程</h3><h3 id="事件分发中的onTouch-和onTouchEvent-有什么区别，又该如何使用？"><a href="#事件分发中的onTouch-和onTouchEvent-有什么区别，又该如何使用？" class="headerlink" title="事件分发中的onTouch 和onTouchEvent 有什么区别，又该如何使用？"></a>事件分发中的onTouch 和onTouchEvent 有什么区别，又该如何使用？</h3><h3 id="View和ViewGroup分别有哪些事件分发相关的回调方法"><a href="#View和ViewGroup分别有哪些事件分发相关的回调方法" class="headerlink" title="View和ViewGroup分别有哪些事件分发相关的回调方法"></a>View和ViewGroup分别有哪些事件分发相关的回调方法</h3><h3 id="View刷新机制"><a href="#View刷新机制" class="headerlink" title="View刷新机制"></a>View刷新机制</h3><h3 id="View绘制流程"><a href="#View绘制流程" class="headerlink" title="View绘制流程"></a>View绘制流程</h3><h3 id="自定义控件原理"><a href="#自定义控件原理" class="headerlink" title="自定义控件原理"></a>自定义控件原理</h3><h3 id="自定义View如何提供获取View属性的接口？"><a href="#自定义View如何提供获取View属性的接口？" class="headerlink" title="自定义View如何提供获取View属性的接口？"></a>自定义View如何提供获取View属性的接口？</h3><h3 id="Android代码中实现WAP方式联网"><a href="#Android代码中实现WAP方式联网" class="headerlink" title="Android代码中实现WAP方式联网"></a>Android代码中实现WAP方式联网</h3><h3 id="AsyncTask机制"><a href="#AsyncTask机制" class="headerlink" title="AsyncTask机制"></a>AsyncTask机制</h3><h3 id="AsyncTask原理及不足"><a href="#AsyncTask原理及不足" class="headerlink" title="AsyncTask原理及不足"></a>AsyncTask原理及不足</h3><h3 id="如何取消AsyncTask？"><a href="#如何取消AsyncTask？" class="headerlink" title="如何取消AsyncTask？"></a>如何取消AsyncTask？</h3><h3 id="为什么不能在子线程更新UI？"><a href="#为什么不能在子线程更新UI？" class="headerlink" title="为什么不能在子线程更新UI？"></a>为什么不能在子线程更新UI？</h3><h3 id="ANR产生的原因是什么？"><a href="#ANR产生的原因是什么？" class="headerlink" title="ANR产生的原因是什么？"></a>ANR产生的原因是什么？</h3><h3 id="ANR定位和修正"><a href="#ANR定位和修正" class="headerlink" title="ANR定位和修正"></a>ANR定位和修正</h3><h3 id="oom是什么？"><a href="#oom是什么？" class="headerlink" title="oom是什么？"></a>oom是什么？</h3><h3 id="什么情况导致oom？"><a href="#什么情况导致oom？" class="headerlink" title="什么情况导致oom？"></a>什么情况导致oom？</h3><h3 id="有什么解决方法可以避免OOM？"><a href="#有什么解决方法可以避免OOM？" class="headerlink" title="有什么解决方法可以避免OOM？"></a>有什么解决方法可以避免OOM？</h3><h3 id="Oom-是否可以try-catch？为什么？"><a href="#Oom-是否可以try-catch？为什么？" class="headerlink" title="Oom 是否可以try catch？为什么？"></a>Oom 是否可以try catch？为什么？</h3><h3 id="内存泄漏是什么？"><a href="#内存泄漏是什么？" class="headerlink" title="内存泄漏是什么？"></a>内存泄漏是什么？</h3><h3 id="什么情况导致内存泄漏？"><a href="#什么情况导致内存泄漏？" class="headerlink" title="什么情况导致内存泄漏？"></a>什么情况导致内存泄漏？</h3><h3 id="如何防止线程的内存泄漏？"><a href="#如何防止线程的内存泄漏？" class="headerlink" title="如何防止线程的内存泄漏？"></a>如何防止线程的内存泄漏？</h3><h3 id="内存泄露场的解决方法"><a href="#内存泄露场的解决方法" class="headerlink" title="内存泄露场的解决方法"></a>内存泄露场的解决方法</h3><h3 id="内存泄漏和内存溢出区别？"><a href="#内存泄漏和内存溢出区别？" class="headerlink" title="内存泄漏和内存溢出区别？"></a>内存泄漏和内存溢出区别？</h3><h3 id="LruCache默认缓存大小"><a href="#LruCache默认缓存大小" class="headerlink" title="LruCache默认缓存大小"></a>LruCache默认缓存大小</h3><h3 id="ContentProvider的权限管理-解答：读写分离，权限控制-精确到表级，URL控制"><a href="#ContentProvider的权限管理-解答：读写分离，权限控制-精确到表级，URL控制" class="headerlink" title="ContentProvider的权限管理(解答：读写分离，权限控制-精确到表级，URL控制)"></a>ContentProvider的权限管理(解答：读写分离，权限控制-精确到表级，URL控制)</h3><h3 id="如何通过广播拦截和abort一条短信？"><a href="#如何通过广播拦截和abort一条短信？" class="headerlink" title="如何通过广播拦截和abort一条短信？"></a>如何通过广播拦截和abort一条短信？</h3><h3 id="广播是否可以请求网络？"><a href="#广播是否可以请求网络？" class="headerlink" title="广播是否可以请求网络？"></a>广播是否可以请求网络？</h3><h3 id="广播引起anr的时间限制是多少？"><a href="#广播引起anr的时间限制是多少？" class="headerlink" title="广播引起anr的时间限制是多少？"></a>广播引起anr的时间限制是多少？</h3><h3 id="计算一个view的嵌套层级"><a href="#计算一个view的嵌套层级" class="headerlink" title="计算一个view的嵌套层级"></a>计算一个view的嵌套层级</h3><h3 id="Activity栈"><a href="#Activity栈" class="headerlink" title="Activity栈"></a>Activity栈</h3><h3 id="Android线程有没有上限？"><a href="#Android线程有没有上限？" class="headerlink" title="Android线程有没有上限？"></a>Android线程有没有上限？</h3><h3 id="线程池有没有上限？"><a href="#线程池有没有上限？" class="headerlink" title="线程池有没有上限？"></a>线程池有没有上限？</h3><h3 id="ListView重用的是什么？"><a href="#ListView重用的是什么？" class="headerlink" title="ListView重用的是什么？"></a>ListView重用的是什么？</h3><h3 id="Android为什么引入Parcelable？"><a href="#Android为什么引入Parcelable？" class="headerlink" title="Android为什么引入Parcelable？"></a>Android为什么引入Parcelable？</h3><h3 id="有没有尝试简化Parcelable的使用？"><a href="#有没有尝试简化Parcelable的使用？" class="headerlink" title="有没有尝试简化Parcelable的使用？"></a>有没有尝试简化Parcelable的使用？</h3><h3 id="四、开发中常见的一些问题"><a href="#四、开发中常见的一些问题" class="headerlink" title="四、开发中常见的一些问题"></a>四、开发中常见的一些问题</h3><h3 id="ListView-中图片错位的问题是如何产生的"><a href="#ListView-中图片错位的问题是如何产生的" class="headerlink" title="ListView 中图片错位的问题是如何产生的?"></a>ListView 中图片错位的问题是如何产生的?</h3><h3 id="混合开发有了解吗？"><a href="#混合开发有了解吗？" class="headerlink" title="混合开发有了解吗？"></a>混合开发有了解吗？</h3><h3 id="知道哪些混合开发的方式？说出它们的优缺点和各自使用场景？（解答：比如-RN，weex，H5，小程序，WPA等。做Android的了解一些前端js等还是很有好处的-；"><a href="#知道哪些混合开发的方式？说出它们的优缺点和各自使用场景？（解答：比如-RN，weex，H5，小程序，WPA等。做Android的了解一些前端js等还是很有好处的-；" class="headerlink" title="知道哪些混合开发的方式？说出它们的优缺点和各自使用场景？（解答：比如:RN，weex，H5，小程序，WPA等。做Android的了解一些前端js等还是很有好处的)；"></a>知道哪些混合开发的方式？说出它们的优缺点和各自使用场景？（解答：比如:RN，weex，H5，小程序，WPA等。做Android的了解一些前端js等还是很有好处的)；</h3><h3 id="屏幕适配的处理技巧都有哪些"><a href="#屏幕适配的处理技巧都有哪些" class="headerlink" title="屏幕适配的处理技巧都有哪些?"></a>屏幕适配的处理技巧都有哪些?</h3><h3 id="服务器只提供数据接收接口，在多线程或多进程条件下，如何保证数据的有序到达？"><a href="#服务器只提供数据接收接口，在多线程或多进程条件下，如何保证数据的有序到达？" class="headerlink" title="服务器只提供数据接收接口，在多线程或多进程条件下，如何保证数据的有序到达？"></a>服务器只提供数据接收接口，在多线程或多进程条件下，如何保证数据的有序到达？</h3><h3 id="动态布局的理解"><a href="#动态布局的理解" class="headerlink" title="动态布局的理解"></a>动态布局的理解</h3><h3 id="怎么去除重复代码？"><a href="#怎么去除重复代码？" class="headerlink" title="怎么去除重复代码？"></a>怎么去除重复代码？</h3><h3 id="画出-Android-的大体架构图"><a href="#画出-Android-的大体架构图" class="headerlink" title="画出 Android 的大体架构图"></a>画出 Android 的大体架构图</h3><h3 id="Recycleview和ListView的区别"><a href="#Recycleview和ListView的区别" class="headerlink" title="Recycleview和ListView的区别"></a>Recycleview和ListView的区别</h3><h3 id="ListView图片加载错乱的原理和解决方案"><a href="#ListView图片加载错乱的原理和解决方案" class="headerlink" title="ListView图片加载错乱的原理和解决方案"></a>ListView图片加载错乱的原理和解决方案</h3><h3 id="动态权限适配方案，权限组的概念"><a href="#动态权限适配方案，权限组的概念" class="headerlink" title="动态权限适配方案，权限组的概念"></a>动态权限适配方案，权限组的概念</h3><h3 id="Android系统为什么会设计ContentProvider？"><a href="#Android系统为什么会设计ContentProvider？" class="headerlink" title="Android系统为什么会设计ContentProvider？"></a>Android系统为什么会设计ContentProvider？</h3><h3 id="下拉状态栏是不是影响activity的生命周期"><a href="#下拉状态栏是不是影响activity的生命周期" class="headerlink" title="下拉状态栏是不是影响activity的生命周期"></a>下拉状态栏是不是影响activity的生命周期</h3><h3 id="如果在onStop的时候做了网络请求，onResume的时候怎么恢复？"><a href="#如果在onStop的时候做了网络请求，onResume的时候怎么恢复？" class="headerlink" title="如果在onStop的时候做了网络请求，onResume的时候怎么恢复？"></a>如果在onStop的时候做了网络请求，onResume的时候怎么恢复？</h3><h3 id="Bitmap-使用时候注意什么？"><a href="#Bitmap-使用时候注意什么？" class="headerlink" title="Bitmap 使用时候注意什么？"></a>Bitmap 使用时候注意什么？</h3><h3 id="Bitmap的recycler"><a href="#Bitmap的recycler" class="headerlink" title="Bitmap的recycler()"></a>Bitmap的recycler()</h3><h3 id="Android中开启摄像头的主要步骤"><a href="#Android中开启摄像头的主要步骤" class="headerlink" title="Android中开启摄像头的主要步骤"></a>Android中开启摄像头的主要步骤</h3><h3 id="ViewPager使用细节，如何设置成每次只初始化当前的Fragment，其他的不初始化？"><a href="#ViewPager使用细节，如何设置成每次只初始化当前的Fragment，其他的不初始化？" class="headerlink" title="ViewPager使用细节，如何设置成每次只初始化当前的Fragment，其他的不初始化？"></a>ViewPager使用细节，如何设置成每次只初始化当前的Fragment，其他的不初始化？</h3><h3 id="点击事件被拦截，但是想传到下面的View，如何操作？"><a href="#点击事件被拦截，但是想传到下面的View，如何操作？" class="headerlink" title="点击事件被拦截，但是想传到下面的View，如何操作？"></a>点击事件被拦截，但是想传到下面的View，如何操作？</h3><h3 id="微信主页面的实现方式"><a href="#微信主页面的实现方式" class="headerlink" title="微信主页面的实现方式"></a>微信主页面的实现方式</h3><h3 id="微信上消息小红点的原理"><a href="#微信上消息小红点的原理" class="headerlink" title="微信上消息小红点的原理"></a>微信上消息小红点的原理</h3><h3 id="CAS介绍（这是阿里巴巴的面试题，我不是很了解，可以参考博客-CAS简介）"><a href="#CAS介绍（这是阿里巴巴的面试题，我不是很了解，可以参考博客-CAS简介）" class="headerlink" title="CAS介绍（这是阿里巴巴的面试题，我不是很了解，可以参考博客: CAS简介）"></a>CAS介绍（这是阿里巴巴的面试题，我不是很了解，可以参考博客: CAS简介）</h3>]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>interview/docker</title>
    <url>/2020/10/10/interview-docker/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/tools/Docker-Image.md">https://github.com/Snailclimb/JavaGuide/blob/master/docs/tools/Docker-Image.md</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>interview/git</title>
    <url>/2020/10/10/interview-git/</url>
    <content><![CDATA[<h2 id="Q1-Git-和-SVN-有什么区别？"><a href="#Q1-Git-和-SVN-有什么区别？" class="headerlink" title="Q1. Git 和 SVN 有什么区别？"></a>Q1. Git 和 SVN 有什么区别？</h2><table>
<thead>
<tr>
<th>Git</th>
<th>SVN</th>
</tr>
</thead>
<tbody><tr>
<td>1. Git 是一个分布式的版本控制工具</td>
<td>1. SVN 是集中版本控制工具</td>
</tr>
<tr>
<td>2.它属于第 3 代版本控制工具</td>
<td>2.它属于第 2 代版本控制工具</td>
</tr>
<tr>
<td>3.客户端可以在其本地系统上克隆整个存储库</td>
<td>3.版本历史记录存储在服务器端存储库中</td>
</tr>
<tr>
<td>4.即使离线也可以提交</td>
<td>4.只允许在线提交</td>
</tr>
<tr>
<td>5.Push/pull 操作更快</td>
<td>5.Push/pull 操作较慢</td>
</tr>
<tr>
<td>6.工程可以用 commit 自动共享</td>
<td>6.没有任何东西自动共享</td>
</tr>
</tbody></table>
<h2 id="Q2-什么是-Git？"><a href="#Q2-什么是-Git？" class="headerlink" title="Q2. 什么是 Git？"></a>Q2. 什么是 Git？</h2><p>我建议你先通过了解 git 的架构再来回答这个问题，如下图所示，试着解释一下这个图：<br>Git 是分布式版本控制系统（DVCS）。它可以跟踪文件的更改，并允许你恢复到任何特定版本的更改。<br>与 SVN 等其他版本控制系统（VCS）相比，其分布式架构具有许多优势，一个主要优点是它不依赖于中央服务器来存储项目文件的所有版本。<br>每个开发人员都可以“克隆”我在图中用“Local repository”标注的存储库的副本，并且在他的硬盘驱动器上具有项目的完整历史记录，因此当服务器中断时，你需要的所有恢复数据都在你队友的本地 Git 存储库中。<br>还有一个中央云存储库，开发人员可以向其提交更改，并与其他团队成员进行共享，如图所示，所有协作者都在提交更改“远程存储库”。</p>
<p>下一组 Git 面试问题将测试你使用 Git 的体验：</p>
<h2 id="Q3-在-Git-中提交的命令是什么？"><a href="#Q3-在-Git-中提交的命令是什么？" class="headerlink" title="Q3. 在 Git 中提交的命令是什么？"></a>Q3. 在 Git 中提交的命令是什么？</h2><p>答案非常简单。<br>用于写入提交的命令是 git commit -a。<br>现在解释一下 -a 标志， 通过在命令行上加 -a 指示 git 提交已修改的所有被跟踪文件的新内容。还要提一下，如果你是第一次需要提交新文件，可以在在 git commit -a 之前先 git add <file>。</p>
<h2 id="Q4-什么是-Git-中的“裸存储库”？"><a href="#Q4-什么是-Git-中的“裸存储库”？" class="headerlink" title="Q4. 什么是 Git 中的“裸存储库”？"></a>Q4. 什么是 Git 中的“裸存储库”？</h2><p>你应该说明 “工作目录” 和 “裸存储库” 之间的区别。<br>Git 中的 “裸” 存储库只包含版本控制信息而没有工作文件（没有工作树），并且它不包含特殊的 .git 子目录。相反，它直接在主目录本身包含 .git 子目录中的所有内容，其中工作目录包括：<br>一个 .git 子目录，其中包含你的仓库所有相关的 Git 修订历史记录。<br>工作树，或签出的项目文件的副本。</p>
<h2 id="Q5-Git-是用什么语言编写的？"><a href="#Q5-Git-是用什么语言编写的？" class="headerlink" title="Q5. Git 是用什么语言编写的？"></a>Q5. Git 是用什么语言编写的？</h2><p>你需要说明使用它的原因，而不仅仅是说出语言的名称。我建议你这样回答：<br>Git 使用 C 语言编写。 GIT 很快，C 语言通过减少运行时的开销来做到这一点。</p>
<h2 id="Q6-在-Git-中，你如何还原已经-push-并公开的提交？"><a href="#Q6-在-Git-中，你如何还原已经-push-并公开的提交？" class="headerlink" title="Q6. 在 Git 中，你如何还原已经 push 并公开的提交？"></a>Q6. 在 Git 中，你如何还原已经 push 并公开的提交？</h2><p>There can be two answers to this question and make sure that you include both because any of the below options can be used depending on the situation: 1<br>这个问题可以有两个答案，你回答时也要保包含这两个答案，因为根据具体情况可以使用以下选项：<br>删除或修复新提交中的错误文件，并将其推送到远程存储库。这是修复错误的最自然方式。对文件进行必要的修改后，将其提交到我将使用的远程存储库<br>git commit -m “commit message”<br>创建一个新的提交，撤消在错误提交中所做的所有更改。可以使用命令：<br>git revert <name of bad commit></p>
<h2 id="Q7-git-pull-和-git-fetch-有什么区别？"><a href="#Q7-git-pull-和-git-fetch-有什么区别？" class="headerlink" title="Q7. git pull 和 git fetch 有什么区别？"></a>Q7. git pull 和 git fetch 有什么区别？</h2><p>git pull 命令从中央存储库中提取特定分支的新更改或提交，并更新本地存储库中的目标分支。<br>git fetch 也用于相同的目的，但它的工作方式略有不同。当你执行 git fetch 时，它会从所需的分支中提取所有新提交，并将其存储在本地存储库中的新分支中。如果要在目标分支中反映这些更改，必须在 git fetch 之后执行 git merge。只有在对目标分支和获取的分支进行合并后才会更新目标分支。为了方便起见，请记住以下等式：<br>git pull = git fetch + git merge</p>
<h2 id="Q8-git-中的“staging-area”或“index”是什么？-延伸问题-git-本地分区分别是什么"><a href="#Q8-git-中的“staging-area”或“index”是什么？-延伸问题-git-本地分区分别是什么" class="headerlink" title="Q8. git 中的“staging area”或“index”是什么？(延伸问题 git 本地分区分别是什么)"></a>Q8. git 中的“staging area”或“index”是什么？(延伸问题 git 本地分区分别是什么)</h2><p>工作区（Working Directory）:<br>是直接编辑的地方，肉眼可见，直接操作。<br>暂存区（Stage 或 Index）:<br>数据暂时存放的区域。<br>版本库（commit History）:<br>存放已经提交的数据，push 的时候，就是把这个区的数据 push 到远程 git 仓库了。<br>|创建版本库|版本控制|远程协作|查看信息|<br>|-|-|-|-|<br>|git init||git add|git pull|git help|<br>|git clone| git commit| git push|git log|<br>|_| git rm| _| git diff|</p>
<h2 id="Q9-什么是-git-stash"><a href="#Q9-什么是-git-stash" class="headerlink" title="Q9. 什么是 git stash?"></a>Q9. 什么是 git stash?</h2><p>首先应该解释 git stash 的必要性。<br>通常情况下，当你一直在处理项目的某一部分时，如果你想要在某个时候切换分支去处理其他事情，事情会处于混乱的状态。问题是，你不想把完成了一半的工作的提交，以便你以后就可以回到当前的工作。解决这个问题的答案是 git stash。<br>再解释什么是 git stash。<br>stash 会将你的工作目录，即修改后的跟踪文件和暂存的更改保存在一堆未完成的更改中，你可以随时重新应用这些更改。</p>
<h2 id="Q10-什么是-git-stash-drop？"><a href="#Q10-什么是-git-stash-drop？" class="headerlink" title="Q10. 什么是 git stash drop？"></a>Q10. 什么是 git stash drop？</h2><p>通过说明我们使用 git stash drop 的目的来回答这个问题。<br>git stash drop 命令用于删除隐藏的项目。默认情况下，它将删除最后添加的存储项，如果提供参数的话，它还可以删除特定项。<br>下面举个例子。<br>如果要从隐藏项目列表中删除特定的存储项目，可以使用以下命令：<br>git stash list：它将显示隐藏项目列表，如：<br>stash@{0}: WIP on master: 049d078 added the index file<br>stash@{1}: WIP on master: c264051 Revert “added file_size”<br>stash@{2}: WIP on master: 21d80a5 added number to log<br>如果要删除名为 stash@{0} 的项目，请使用命令 git stash drop stash@{0}。</p>
<h2 id="Q11-如何找到特定提交中已更改的文件列表？"><a href="#Q11-如何找到特定提交中已更改的文件列表？" class="headerlink" title="Q11. 如何找到特定提交中已更改的文件列表？"></a>Q11. 如何找到特定提交中已更改的文件列表？</h2><p>对于这个问题，不能仅仅是提供命令，还要解释这个命令究竟做了些什么。<br>要获取特定提交中已更改的列表文件，请使用以下命令：<br>git diff-tree -r {hash}<br>给定提交哈希，这将列出在该提交中更改或添加的所有文件。 -r 标志使命令列出单个文件，而不是仅将它们折叠到根目录名称中。<br>你还可以包括下面提到的内容，虽然它是可选的，但有助于给面试官留下深刻印象。<br>输出还将包含一些额外信息，可以通过包含两个标志把它们轻松的屏蔽掉：<br>git diff-tree –no-commit-id –name-only -r {hash}<br>这里 -no-commit-id 将禁止提交哈希值出现在输出中，而 -name-only 只会打印文件名而不是它们的路径。</p>
<h2 id="Q12-git-config-的功能是什么？（延伸问题-–global-是干什么用的）"><a href="#Q12-git-config-的功能是什么？（延伸问题-–global-是干什么用的）" class="headerlink" title="Q12. git config 的功能是什么？（延伸问题 –global 是干什么用的）"></a>Q12. git config 的功能是什么？（延伸问题 –global 是干什么用的）</h2><p>首先说明为什么我们需要 git config。<br>git 使用你的用户名将提交与身份相关联。 git config 命令可用来更改你的 git 配置，包括你的用户名。<br>下面用一个例子来解释。<br>假设你要提供用户名和电子邮件 ID 用来将提交与身份相关联，以便你可以知道是谁进行了特定提交。为此，我将使用：<br>git config –global user.name “Your Name”: 此命令将添加用户名。<br>git config –global user.email “Your E-mail Address”: 此命令将添加电子邮件 ID。</p>
<h2 id="Q13-提交对象包含什么？"><a href="#Q13-提交对象包含什么？" class="headerlink" title="Q13. 提交对象包含什么？"></a>Q13. 提交对象包含什么？</h2><p>Commit 对象包含以下组件，你应该提到以下这三点：<br>一组文件，表示给定时间点的项目状态<br>引用父提交对象<br>SHAI 名称，一个 40 个字符的字符串，提交对象的唯一标识。</p>
<h2 id="Q14-如何在-Git-中创建存储库？"><a href="#Q14-如何在-Git-中创建存储库？" class="headerlink" title="Q14. 如何在 Git 中创建存储库？"></a>Q14. 如何在 Git 中创建存储库？</h2><p>这可能是最常见的问题，答案很简单。<br>要创建存储库，先为项目创建一个目录（如果该目录不存在），然后运行命令 git init。通过运行此命令，将在项目的目录中创建 .git 目录。</p>
<h2 id="Q15-怎样将-N-次提交压缩成一次提交？"><a href="#Q15-怎样将-N-次提交压缩成一次提交？" class="headerlink" title="Q15. 怎样将 N 次提交压缩成一次提交？"></a>Q15. 怎样将 N 次提交压缩成一次提交？</h2><p>将 N 个提交压缩到单个提交中有两种方式：<br>如果要从头开始编写新的提交消息，请使用以下命令：<br>git reset –soft HEAD<del>N &amp;&amp;<br>git commit<br>如果你想在新的提交消息中串联现有的提交消息，那么需要提取这些消息并将它们传给 git commit，可以这样：<br>git reset –soft HEAD</del>N &amp;&amp;<br>git commit –edit -m”$(git log –format=%B –reverse .HEAD@{N})”</p>
<h2 id="Q16-什么是-Git-bisect？如何使用它来确定（回归）错误的来源？"><a href="#Q16-什么是-Git-bisect？如何使用它来确定（回归）错误的来源？" class="headerlink" title="Q16. 什么是 Git bisect？如何使用它来确定（回归）错误的来源？"></a>Q16. 什么是 Git bisect？如何使用它来确定（回归）错误的来源？</h2><p>我建议你先给出一个 Git bisect 的小定义。<br>Git bisect 用于查找使用二进制搜索引入错误的提交。 Git bisect 的命令是<br>git bisect <subcommand> <options><br>既然你已经提到过上面的命令，那就解释一下这个命令会做什么。<br>此命令用了二进制搜索算法来查找项目历史记录中的哪个提交引入了错误。你可以通过告诉它已知包含该错误的“错误”提交以及在引入错误之前已知的“良好”提交来使用它。然后 git bisect 在这两个端点之间选择一个提交，并询问你所选的提交是“好”还是“坏”。它继续缩小范围，直到找到引入更改的确切提交。</p>
<h2 id="Q18-描述一下你所使用的分支策略？-结合公司的分支策略说，下面只是例子"><a href="#Q18-描述一下你所使用的分支策略？-结合公司的分支策略说，下面只是例子" class="headerlink" title="Q18. 描述一下你所使用的分支策略？(结合公司的分支策略说，下面只是例子)"></a>Q18. 描述一下你所使用的分支策略？(结合公司的分支策略说，下面只是例子)</h2><p>这个问题被要求用 Git 来测试你的分支经验，告诉他们你在以前的工作中如何使用分支以及它的用途是什么，你可以参考以下提到的要点：<br>功能分支（Feature branching）<br>要素分支模型将特定要素的所有更改保留在分支内。当通过自动化测试对功能进行全面测试和验证时，该分支将合并到主服务器中。<br>任务分支（Task branching）<br>在此模型中，每个任务都在其自己的分支上实现，任务键包含在分支名称中。很容易看出哪个代码实现了哪个任务，只需在分支名称中查找任务键。<br>发布分支（Release branching）<br>一旦开发分支获得了足够的发布功能，你就可以克隆该分支来形成发布分支。创建该分支将会启动下一个发布周期，所以在此之后不能再添加任何新功能，只有错误修复，文档生成和其他面向发布的任务应该包含在此分支中。一旦准备好发布，该版本将合并到主服务器并标记版本号。此外，它还应该再将自发布以来已经取得的进展合并回开发分支。<br>最后告诉他们分支策略因团队而异，所以我知道基本的分支操作，如删除、合并、检查分支等。</p>
<h2 id="Q19-如果分支是否已合并为-master，你可以通过什么手段知道？"><a href="#Q19-如果分支是否已合并为-master，你可以通过什么手段知道？" class="headerlink" title="Q19. 如果分支是否已合并为 master，你可以通过什么手段知道？"></a>Q19. 如果分支是否已合并为 master，你可以通过什么手段知道？</h2><p>答案很直接。<br>要知道某个分支是否已合并为 master，你可以使用以下命令：<br>git branch –merged 它列出了已合并到当前分支的分支。<br>git branch –no-merged 它列出了尚未合并的分支。</p>
<h2 id="Q20-如何初始化仓库（包括提交到远程）"><a href="#Q20-如何初始化仓库（包括提交到远程）" class="headerlink" title="Q20.如何初始化仓库（包括提交到远程）"></a>Q20.如何初始化仓库（包括提交到远程）</h2><p>git init<br>git add remote（remote url）<br>git push</p>
<h2 id="Q21-在-Git-中提交的命令是什么？"><a href="#Q21-在-Git-中提交的命令是什么？" class="headerlink" title="Q21.在 Git 中提交的命令是什么？"></a>Q21.在 Git 中提交的命令是什么？</h2><p>git commit 本地提交<br>git push 推送到远程</p>
<h2 id="如何修改本地-commit-message"><a href="#如何修改本地-commit-message" class="headerlink" title="如何修改本地 commit message"></a>如何修改本地 commit message</h2><p>git commit –amend</p>
<h2 id="Q22-如何撤销未-push-的提交"><a href="#Q22-如何撤销未-push-的提交" class="headerlink" title="Q22.如何撤销未 push 的提交"></a>Q22.如何撤销未 push 的提交</h2><p>git reset &lt;版本号&gt;</p>
<h2 id="Q23-如何撤销已经-push-的提交"><a href="#Q23-如何撤销已经-push-的提交" class="headerlink" title="Q23.如何撤销已经 push 的提交"></a>Q23.如何撤销已经 push 的提交</h2><p>git reset –hard &lt;版本号&gt;<br>git push origin &lt;分支名&gt; –force</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>interview/http</title>
    <url>/2020/10/10/interview-http/</url>
    <content><![CDATA[<h2 id="http-协议中各个响应状态返回值的含义"><a href="#http-协议中各个响应状态返回值的含义" class="headerlink" title="http 协议中各个响应状态返回值的含义"></a>http 协议中各个响应状态返回值的含义</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</a></p>
<h2 id="HTTP-八种方法"><a href="#HTTP-八种方法" class="headerlink" title="HTTP 八种方法"></a>HTTP 八种方法</h2><p>OPTIONS<br>GET<br>HEAD<br>POST<br>PUT<br>DELETE<br>TRACE<br>CONNECT</p>
<h2 id="POST-GET-区别"><a href="#POST-GET-区别" class="headerlink" title="POST GET 区别"></a>POST GET 区别</h2><p>get 把请求的数据放在 url 上，即 HTTP 协议头上，其格式为：以?分割 URL 和传输数据，参数之间以&amp;相连。数据如果是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用 BASE64 加密，及“%”加上“字符串的 16 进制 ASCII 码”。post 把数据放在 HTTP 的包体内（requrest body）。<br>get 提交的数据最大是 2k（原则上 url 长度无限制，那么 get 提交的数据也没有限制咯？限制实际上取决于浏览器，(大多数)浏览器通常都会限制 url 长度在 2K 个字节，即使(大多数)服务器最多处理 64K 大小的 url。也没有卵用。）。post 理论上没有限制。实际上 IIS4 中最大量为 80KB，IIS5 中为 100KB。<br>GET 产生一个 TCP 数据包，浏览器会把 http header 和 data 一并发送出去，服务器响应 200(返回数据);POST 产生两个 TCP 数据包，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok(返回数据)。<br>GET 在浏览器回退时是无害的，POST 会再次提交请求。<br>GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。<br>GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。<br>GET 请求只能进行 url 编码，而 POST 支持多种编码方式。<br>GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。<br>GET 只接受 ASCII 字符的参数的数据类型，而 POST 没有限制<br>那么，post 那么好为什么还用 get？get 效率高！。  </p>
<h2 id="REST-接口规范-RESTful-的-6-大原则"><a href="#REST-接口规范-RESTful-的-6-大原则" class="headerlink" title="REST 接口规范, RESTful 的 6 大原则"></a>REST 接口规范, RESTful 的 6 大原则</h2><p><a href="https://zhuanlan.zhihu.com/p/90367875">https://zhuanlan.zhihu.com/p/90367875</a></p>
<h2 id="3-次握手，4-次挥手"><a href="#3-次握手，4-次挥手" class="headerlink" title="3 次握手，4 次挥手"></a>3 次握手，4 次挥手</h2><p>第一次握手(SYN=1, seq=x):</p>
<p>客户端发送一个 TCP 的 SYN 标志位置 1 的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。</p>
<p>发送完毕后，客户端进入 SYN_SEND 状态。</p>
<p>第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):</p>
<p>服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为 1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加 1，即 X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。</p>
<p>第三次握手(ACK=1，ACKnum=y+1)</p>
<p>客户端再次发送确认包(ACK)，SYN 标志位为 0，ACK 标志位为 1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写 ISN 的+1</p>
<p>发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。<br>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。</p>
<p>第一次挥手(FIN=1，seq=x)</p>
<p>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为 1 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p>
<p>发送完毕后，客户端进入 FIN_WAIT_1 状态。</p>
<p>第二次挥手(ACK=1，ACKnum=x+1)</p>
<p>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</p>
<p>发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。</p>
<p>第三次挥手(FIN=1，seq=y)</p>
<p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为 1。</p>
<p>发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个 ACK。</p>
<p>第四次挥手(ACK=1，ACKnum=y+1)</p>
<p>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT 状态，等待可能出现的要求重传的 ACK 包。</p>
<p>服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</p>
<p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。<br><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html">https://hit-alibaba.github.io/interview/basic/network/TCP.html</a></p>
<p><a href="https://blog.csdn.net/qzcsu/article/details/72861891">https://blog.csdn.net/qzcsu/article/details/72861891</a></p>
<h2 id="TCP-和-UDP-区别"><a href="#TCP-和-UDP-区别" class="headerlink" title="TCP 和 UDP 区别"></a>TCP 和 UDP 区别</h2><p>TCP (Transmission Control Protocol)和 UDP(User Datagram Protocol)协议属于传输层协议，它们之间的区别包括：<br>TCP 是面向连接的，UDP 是无连接的；<br>TCP 是可靠的，UDP 是不可靠的；<br>TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多的通信模式；<br>TCP 是面向字节流的，UDP 是面向报文的；<br>TCP 有拥塞控制机制;UDP 没有拥塞控制，适合媒体通信；<br>TCP 首部开销(20 个字节)比 UDP 的首部开销(8 个字节)要大；  </p>
<h2 id="http-和-https-区别"><a href="#http-和-https-区别" class="headerlink" title="http 和 https 区别"></a>http 和 https 区别</h2><p>Http 协议运行在 TCP 之上，明文传输，客户端与服务器端都无法验证对方的身份；Https 是身披 SSL(Secure Socket Layer)外壳的 Http，运行于 SSL 上，SSL 运行于 TCP 之上，是添加了加密和认证机制的 HTTP。二者之间存在如下不同：<br>端口不同：Http 与 Http 使用不同的连接方式，用的端口也不一样，前者是 80，后者是 443；<br>资源消耗：和 HTTP 通信相比，Https 通信会由于加减密处理消耗更多的 CPU 和内存资源；<br>开销：Https 通信需要证书，而证书一般需要向认证机构购买；　 Https 的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。  </p>
<h2 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h2><p>对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。<br>　　由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p>
<h2 id="http1-0-和-http2-0-区别"><a href="#http1-0-和-http2-0-区别" class="headerlink" title="http1.0 和 http2.0 区别"></a>http1.0 和 http2.0 区别</h2><p>新的二进制格式（Binary Format），HTTP1.x 的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 的组合。基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮。<br>多路复用（MultiPlexing），即连接共享，即每一个 request 都是是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面。<br>header 压缩，如上文中所言，对前面提到过 HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。<br>服务端推送（server push），同 SPDY 一样，HTTP2.0 也具有 server push 功能。</p>
<h2 id="Session、Cookie-与-Application"><a href="#Session、Cookie-与-Application" class="headerlink" title="Session、Cookie 与 Application"></a>Session、Cookie 与 Application</h2><p>Cookie：<br>Cookie 和 Session 都是客户端与服务器之间保持状态的解决方案，具体来说，cookie 机制采用的是在客户端保持状态的方案，而 session 机制采用的是在服务器端保持状态的方案。<br>Session：<br>同样地，会话状态也可以保存在服务器端。客户端请求服务器，如果服务器记录该用户状态，就获取 Session 来保存状态，这时，如果服务器已经为此客户端创建过 session，服务器就按照 sessionid 把这个 session 检索出来使用；如果客户端请求不包含 sessionid，则为此客户端创建一个 session 并且生成一个与此 session 相关联的 sessionid，并将这个 sessionid 在本次响应中返回给客户端保存。保存这个 sessionid 的方式可以采用  cookie 机制  ，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器；若浏览器禁用 Cookie 的话，可以通过  URL 重写机制   将 sessionid 传回服务器。<br>Session 与 Cookie 的对比：<br>实现机制：Session 的实现常常依赖于 Cookie 机制，通过 Cookie 机制回传 SessionID；<br>大小限制：Cookie 有大小限制并且浏览器对每个站点也有 cookie 的个数限制，Session 没有大小限制，理论上只与服务器的内存大小有关；<br>安全性：Cookie 存在安全隐患，通过拦截或本地文件找得到 cookie 后可以进行攻击，而 Session 由于保存在服务器端，相对更加安全；<br>服务器资源消耗：Session 是保存在服务器端上会存在一段时间才会消失，如果 session 过多会增加服务器的压力。<br>Application（ServletContext）：与一个 Web 应用程序相对应，为应用程序提供了一个全局的状态，所有客户都可以使用该状态<br> Application：<br>　　 Application（Java Web 中的 ServletContext）：与一个 Web 应用程序相对应，为应用程序提供了一个全局的状态，所有客户都可以使用该状态。  </p>
]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>interview/linux</title>
    <url>/2020/10/10/interview-linux/</url>
    <content><![CDATA[<h2 id="列举你了解的几个-linux-shell-类型"><a href="#列举你了解的几个-linux-shell-类型" class="headerlink" title="列举你了解的几个 linux shell 类型"></a>列举你了解的几个 linux shell 类型</h2><p>常见的有<br>Bourne Again Shell (简称 bash)、<br>Bourne Shell（简称 sh）、<br>C-Shelll（简称 csh）、<br>Korn Shell（简称 ksh）<br><a href="https://blog.csdn.net/chentiefeng521/article/details/52601311">https://blog.csdn.net/chentiefeng521/article/details/52601311</a></p>
<h2 id="如何指定-shell-脚本所使用的的-shell-类型"><a href="#如何指定-shell-脚本所使用的的-shell-类型" class="headerlink" title="如何指定 shell 脚本所使用的的 shell 类型"></a>如何指定 shell 脚本所使用的的 shell 类型</h2><p>Shell 第一行加入# /bin/bash</p>
<h2 id="查看-app-log-的内容的几种方式"><a href="#查看-app-log-的内容的几种方式" class="headerlink" title="查看./app.log 的内容的几种方式"></a>查看./app.log 的内容的几种方式</h2><p>cat ./app.log<br>vi ./app.log<br>more ./app.log</p>
<h2 id="查看-app-log-的开始-100-行"><a href="#查看-app-log-的开始-100-行" class="headerlink" title="查看./app.log 的开始 100 行"></a>查看./app.log 的开始 100 行</h2><p>head -n 20 filename</p>
<h2 id="查看-app-log-的最后-100-行"><a href="#查看-app-log-的最后-100-行" class="headerlink" title="查看./app.log 的最后 100 行"></a>查看./app.log 的最后 100 行</h2><p>tail -n 100 ./app.log</p>
<h2 id="打印-app-log-包含-application-info-的所有行"><a href="#打印-app-log-包含-application-info-的所有行" class="headerlink" title="打印./app.log 包含 application-info 的所有行"></a>打印./app.log 包含 application-info 的所有行</h2><p>cat ./app.log | grep application-info</p>
<h2 id="查找根目录下所有名为-app-log-的文件（不包含文件夹）"><a href="#查找根目录下所有名为-app-log-的文件（不包含文件夹）" class="headerlink" title="查找根目录下所有名为 app.log 的文件（不包含文件夹）"></a>查找根目录下所有名为 app.log 的文件（不包含文件夹）</h2><p>find / -type f -name ‘app.log’</p>
<h2 id="Linux-三个权限数字是什么，分别代表什么"><a href="#Linux-三个权限数字是什么，分别代表什么" class="headerlink" title="Linux 三个权限数字是什么，分别代表什么"></a>Linux 三个权限数字是什么，分别代表什么</h2><p>4 读<br>2 写<br>1 执行</p>
<h2 id="只有拥有者有读写权限。"><a href="#只有拥有者有读写权限。" class="headerlink" title="只有拥有者有读写权限。"></a>只有拥有者有读写权限。</h2><p>-rw——- (600)</p>
<h2 id="只有拥有者有读写权限；而属组用户和其他用户只有读权限。"><a href="#只有拥有者有读写权限；而属组用户和其他用户只有读权限。" class="headerlink" title="只有拥有者有读写权限；而属组用户和其他用户只有读权限。"></a>只有拥有者有读写权限；而属组用户和其他用户只有读权限。</h2><p>-rw-r–r– (644)</p>
<h2 id="只有拥有者有读、写、执行权限。"><a href="#只有拥有者有读、写、执行权限。" class="headerlink" title="只有拥有者有读、写、执行权限。"></a>只有拥有者有读、写、执行权限。</h2><p>-rwx—— (700)</p>
<h2 id="拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。"><a href="#拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。" class="headerlink" title="拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。"></a>拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。</h2><p>-rwxr-xr–x (755)</p>
<h2 id="拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。"><a href="#拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。" class="headerlink" title="拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。"></a>拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。</h2><p>-rwx–x–x (711)</p>
<h2 id="所有用户都有文件读、写权限。"><a href="#所有用户都有文件读、写权限。" class="headerlink" title="所有用户都有文件读、写权限。"></a>所有用户都有文件读、写权限。</h2><p>-rw-rw-rw- (666)</p>
<h2 id="所有用户都有读、写、执行权限。"><a href="#所有用户都有读、写、执行权限。" class="headerlink" title="所有用户都有读、写、执行权限。"></a>所有用户都有读、写、执行权限。</h2><p>-rwxrwxrwx (777)</p>
<h2 id="查看当前目录下所有文件的权限"><a href="#查看当前目录下所有文件的权限" class="headerlink" title="查看当前目录下所有文件的权限"></a>查看当前目录下所有文件的权限</h2><p>ls -l</p>
<h2 id="复制-dic1-文件夹下所有文件和文件夹到-dic2"><a href="#复制-dic1-文件夹下所有文件和文件夹到-dic2" class="headerlink" title="复制 dic1 文件夹下所有文件和文件夹到 dic2"></a>复制 dic1 文件夹下所有文件和文件夹到 dic2</h2><p>cp -rf dic1/* dic2/</p>
<h2 id="移动当前文件夹下所有文件到上一级文件夹"><a href="#移动当前文件夹下所有文件到上一级文件夹" class="headerlink" title="移动当前文件夹下所有文件到上一级文件夹"></a>移动当前文件夹下所有文件到上一级文件夹</h2><p>mv * ../</p>
<h2 id="删除当前文件夹无需询问"><a href="#删除当前文件夹无需询问" class="headerlink" title="删除当前文件夹无需询问"></a>删除当前文件夹无需询问</h2><p>rm -rf .</p>
<h2 id="创建文件夹-abc-cde-efg（多级）"><a href="#创建文件夹-abc-cde-efg（多级）" class="headerlink" title="创建文件夹 ./abc/cde/efg（多级）"></a>创建文件夹 ./abc/cde/efg（多级）</h2><p>mkdir -p ./abc/cde/efg</p>
<h2 id="写出创建文件的三种方式"><a href="#写出创建文件的三种方式" class="headerlink" title="写出创建文件的三种方式"></a>写出创建文件的三种方式</h2><p>touch aaa.txt<br>vi aaa.txt 保存退出<br>echo ‘’ &gt; aaa.txt</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>java 设计模式</title>
    <url>/2020/10/10/java-patterns/</url>
    <content><![CDATA[<ol>
<li>软件设计模式概述</li>
<li>GoF 的 23 种设计模式的分类和功能</li>
<li>UML中的类图及类图之间的关系</li>
<li>开闭原则——面向对象设计原则</li>
<li>里氏替换原则——面向对象设计原则</li>
<li>依赖倒置原则——面向对象设计原则</li>
<li>单一职责原则——面向对象设计原则</li>
<li>接口隔离原则——面向对象设计原则</li>
<li>迪米特法则——面向对象设计原则</li>
<li>合成复用原则——面向对象设计原则</li>
<li>创建型模式的特点和分类</li>
<li>单例模式（单例设计模式）详解</li>
<li>原型模式（原型设计模式）详解</li>
<li>简单工厂模式</li>
<li>工厂方法模式（详解版）</li>
<li>抽象工厂模式（详解版）</li>
<li>建造者模式（Bulider模式）详解</li>
<li>结构型模式概述（结构型模式的分类）</li>
<li>代理模式（代理设计模式）详解</li>
<li>适配器模式（Adapter模式）详解</li>
<li>桥接模式（Bridge模式）详解</li>
<li>装饰模式（装饰设计模式）详解</li>
<li>外观模式（Facade模式）详解</li>
<li>享元模式（详解版）</li>
<li>组合模式（详解版）</li>
<li>行为型模式概述（行为型模式的分类）</li>
<li>模板方法模式（模板方法设计模式）详解</li>
<li>策略模式（策略设计模式）详解</li>
<li>命令模式（详解版）</li>
<li>责任链模式（职责链模式）详解</li>
<li>状态模式（详解版）</li>
<li>观察者模式（Observer模式）详解</li>
<li>中介者模式（详解版）</li>
<li>迭代器模式（详解版）</li>
<li>访问者模式（Visitor模式）详解</li>
<li>备忘录模式（详解版）</li>
<li>解释器模式（详解版）</li>
<li>UMLet的使用与类图的设计</li>
<li>创建型模式应用实验</li>
<li>结构型模式应用实验</li>
<li>行为型模式应用实验</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>jdk9、jdk10、jdk11、jdk12、jdk13新特性</title>
    <url>/2020/10/10/jdk-new-feature/</url>
    <content><![CDATA[<p>我们绝大部分人估计都还在用着jdk8，12其实是一个非LTS（long time support）版本，而11与8一样是LTS版，意味着下个通用的版本将从8直接到11，毕竟11包含了9和10的所有新特性，因此9和10估计就直接被废弃啦。不过9、10、11、12面向开发者的新特性其实并不是很多，大部分都是一些优化、收集器加强以及增加了一些新功能等等<br>而我们开发人员最为关注的肯定是对我们搬砖有用的特性，虽然可能还用不太上，但这边还是先记录一下从jdk9-12的新特性：</p>
<p>jdk9新特性</p>
<p>1、集合加强</p>
<p>jdk9为所有集合（List/Set/Map）都增加了of和copyOf方法，用来创建不可变集合，即一旦创建就无法再执行添加、删除、替换、排序等操作，否则将报java.lang.UnsupportedOperationException异常。一般在特定场景下用还是可以的，不过如果引用了guava库的话推荐还是使用guava把hhhh，例子如下：<br>    List strs = List.of(“Hello”, “World”);</p>
<pre><code> List strsCopy = List. copyOf(strs);

 Set strs = Set.of(&quot;Hello&quot;, &quot;World&quot;);

 Map maps = Map.of(&quot;Hello&quot;, 1, &quot;World&quot;, 2);</code></pre>
<p>2、私有接口方法</p>
<p>jdk8提供了接口的默认方法（default）和静态方法，打破了之前接口只能定义方法而不能存在行为。jdk9则是允许接口定义私有方法，私有方法可以作为通用方法放在默认方法中调用，不过实际中并无多大用处，至少对我来说。<br>3、垃圾收集机制</p>
<p>jdk9把G1作为默认的垃圾收集器实现，替换了jdk7和jdk8的默认垃圾收集器实现：Parallel Scavenge（新生代）+Parallel Old（老年代）。<br>4、I/O流加强</p>
<p>java.io.InputStream 中增加了新的方法来读取和复制 InputStream 中包含的数据：<br>readAllBytes：读取 InputStream 中的所有剩余字节<br>readNBytes： 从 InputStream 中读取指定数量的字节到数组中<br>transferTo：读取 InputStream 中的全部字节并写入到指定的 OutputStream 中<br>5、JShell工具</p>
<p>jdk9引入了jshell这个交互性工具，让Java也可以像脚本语言一样来运行，可以从控制台启动 jshell ，在 jshell 中直接输入表达式并查看其执行结果。当需要测试一个方法的运行效果，或是快速的对表达式进行求值时，jshell 都非常实用。举个例子：</p>
<p>jdk10新特性</p>
<p>1、局部变量类型推断</p>
<p>局部变量类型推断可以说是jdk10中最值得注意的特性，这是Java语言开发人员为了简化Java应用程序的编写而采取的又一步，举个例子：<br>原先我们需要这么定义一个list<br>List<String> list = new ArrayList&lt;&gt;();<br> 使用局部类型推断var关键词定义<br>var list = new ArrayList<String>();<br> 不过局部变量类型推断仅仅适用在：<br>有初始化值的局部变量<br>增强 for 循环中的索引<br>传统 for 循环中声明的局部变量<br>Oracle 的 Java 团队申明，以下不支持局部变量类型推断：<br>方法参数<br>构造函数参数<br>方法返回类型<br>字段<br>catch 代码块（或任何其他类型的变量声明）<br>2、线程本地握手</p>
<p>jdk10将引入一种在线程上执行回调的新方法，因此这将会很方便能停止单个线程而不是停止全部线程或者一个都不停。说实话并不是很懂是什么意思…<br>3、GC改进和内存管理</p>
<p>jdk10中有2个JEP专门用于改进当前的垃圾收集元素。<br>第一个垃圾收集器接口是（JEP 304），它将引入一个纯净的垃圾收集器接口，以帮助改进不同垃圾收集器的源代码隔离。<br>预定用于Java 10的第二个JEP是针对G1的并行完全GC（JEP 307），其重点在于通过完全GC并行来改善G1最坏情况的等待时间。G1是Java 9中的默认GC，并且此JEP的目标是使G1平行。</p>
<p>jdk11新特性</p>
<p>1、字符串加强</p>
<p>// 判断字符串是否为空白<br> “ “.isBlank(); // true<br> // 去除首尾空格<br> “ Javastack “.strip(); // “Javastack”<br> // 去除尾部空格<br> “ Javastack “.stripTrailing();<br> // 去除首部空格<br> “ Javastack “.stripLeading(); // “Javastack “<br> // 复制字符串<br> “Java”.repeat(3); // “JavaJavaJava”<br> // 行数统计<br> “A\nB\nC”.lines().count(); // 3<br>2、HttClient Api</p>
<p>这是 Java 9 开始引入的一个处理 HTTP 请求的的孵化 HTTP Client API，该 API 支持同步和异步，而在 Java 11 中已经为正式可用状态，你可以在java.net包中找到这个 Api<br>3、用于 Lambda 参数的局部变量语法</p>
<p>用于 Lambda 参数的局部变量语法简单来说就是支持类型推导：<br>var x = new A();</p>
<p> for (var x : xs) { … }</p>
<p> try (var x = …) { … } catch …<br>4、ZGC</p>
<p>从JDK 9开始，JDK使用G1作为默认的垃圾回收器。G1可以说是GC的一个里程碑，G1之前的GC回收，还是基于固定的内存区域，而G1采用了一种“细粒度”的内存管理策略，不在固定的区分内存区域属于surviors、eden、old，而我们不需要再去对于年轻代使用一种回收策略，老年代使用一种回收策略，取而代之的是一种整体的内存回收策略。这种回收策略在我们当下cpu、内存、服务规模都越来越大的情况下提供了更好的表现，而这一代ZGC更是有了突破性的进步。<br>从原理上来理解，ZGC可以看做是G1之上更细粒度的内存管理策略。由于内存的不断分配回收会产生大量的内存碎片空间，因此需要整理策略防止内存空间碎片化，在整理期间需要将对于内存引用的线程逻辑暂停，这个过程被称为”Stop the world”。只有当整理完成后，线程逻辑才可以继续运行，一般而言，主要有如下几种方式优化”Stop the world”：<br>使用多个线程同时回收（并行回收）<br> 回收过程分为多次停顿（增量回收）<br> 在程序运行期间回收，不需要停顿或只停顿很短时间（并发回收）<br> 只回收内存而不整理内存<br> ZGC主要采用的是并发回收的策略，相较于G1 ZGC最主要的提升是使用Load Barrier技术实现，引用R大对于ZGC的评价：<br>与标记对象的传统算法相比，ZGC在指针上做标记，在访问指针时加入Load Barrier（读屏障），比如当对象正被GC移动，指针上的颜色就会不对，这个屏障就会先把指针更新为有效地址再返回，也就是，永远只有单个对象读取时有概率被减速，而不存在为了保持应用与GC一致而粗暴整体的Stop The World。</p>
<p>jdk12新特性</p>
<p>1、Switch Expressions</p>
<p>这是一个为开发者准备的特性，我们可以利用具体代码快速了解一下，下面是传统 statement 形式的 switch 语法：<br>switch (day) {<br> case MONDAY:<br> case FRIDAY:<br> case SUNDAY:<br> System.out.println(6);<br> break;<br> case TUESDAY:<br> System.out.println(7);<br> break;<br> case THURSDAY:<br> case SATURDAY:<br> System.out.println(8);<br> break;<br> case WEDNESDAY:<br> System.out.println(9);<br> break;<br> }<br> 如果有编码经验，你一定知道，switch 语句如果漏写了一个 break，那么逻辑往往就跑偏了，这种方式既繁琐，又容易出错。如果换成 switch 表达式，Pattern Matching 机制能够自然地保证只有单一路径会被执行，请看下面的代码示例：<br>switch (day) {<br> case MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(6);<br> case TUESDAY -&gt; System.out.println(7);<br> case THURSDAY, SATURDAY -&gt; System.out.println(8);<br> case WEDNESDAY -&gt; System.out.println(9);<br> }<br> 更进一步，下面的表达式，为我们提供了优雅地表达特定场合计算逻辑的方式<br>int numLetters = switch (day) {<br> case MONDAY, FRIDAY, SUNDAY -&gt; 6;<br> case TUESDAY -&gt; 7;<br> case THURSDAY, SATURDAY -&gt; 8;<br> case WEDNESDAY -&gt; 9;<br> };<br> Switch Expressions 或者说起相关的 Pattern Matching 特性，为我们提供了勾勒出了 Java 语法进化的一个趋势，将开发者从复杂繁琐的低层次抽象中逐渐解放出来，以更高层次更优雅的抽象，既降低代码量，又避免意外编程错误的出现，进而提高代码质量和开发效率。<br>2、Shenandoah GC</p>
<p>新增了一个名为 Shenandoah 的 GC 算法，通过与正在运行的 Java 线程同时进行 evacuation 工作来减少 GC 暂停时间。使用 Shenandoah 的暂停时间与堆大小无关，这意味着无论堆是 200 MB 还是 200 GB，都将具有相同的暂停时间。<br> JDK13新特性</p>
<p>JDK13于9月17日正式发布。目前该版本包含的特性已经全部固定，主要包含以下五个：</p>
<p>下面来逐一介绍下这五个重要的特性。<br>Dynamic CDS Archives<br>这一特性是在JEP310：Application Class-Data Sharing基础上扩展而来的，Dynamic CDS Archives中的CDS指的就是Class-Data Sharing。<br>那么，这个JEP310是个啥东西呢？<br>我们知道在同一个物理机／虚拟机上启动多个JVM时，如果每个虚拟机都单独装载自己需要的所有类，启动成本和内存占用是比较高的。所以Java团队引入了CDS的概念，通过把一些核心类在每个JVM间共享，每个JVM只需要装载自己的应用类，启动时间减少了，另外核心类是共享的，所以JVM的内存占用也减少了。<br>CDS 只能作用于 Boot Class Loader 加载的类，不能作用于 App Class Loader 或者自定义的 Class Loader 加载的类。<br>在 Java 10 中，则将 CDS 扩展为 AppCDS，顾名思义，AppCDS 不止能够作用于 Boot Class Loader了，App Class Loader 和自定义的 Class Loader 也都能够起作用，大大加大了 CDS 的适用范围。也就说开发自定义的类也可以装载给多个JVM共享了。<br>Java 10中包含的JEP310的通过跨不同Java进程共享公共类元数据来减少了内存占用和改进了启动时间。<br>但是，JEP310中，使用AppCDS的过程还是比较复杂的，需要有三个步骤：</p>
<p> 这一次的JDK 13中的JEP 350 ，在JEP310的基础上，又做了一些扩展。允许在Java应用程序执行结束时动态归档类，归档类将包括默认的基础层 CDS（class data-sharing）存档中不存在的所有已加载的应用程序类和库类。<br>也就是说，在Java 13中再使用AppCDS的时候，就不在需要这么复杂了。<br>ZGC: Uncommit Unused Memory<br>在讨论这个问题之前，想先问一个问题，JVM的GC释放的内存会还给操作系统吗？<br>GC后的内存如何处置，其实是取决于不同的垃圾回收器的。因为把内存还给OS，意味着要调整JVM的堆大小，这个过程是比较耗费资源的。<br>在JDK 11中，Java引入了ZGC，这是一款可伸缩的低延迟垃圾收集器，但是当时只是实验性的。并且，ZGC释放的内存是不会还给操作系统的。</p>
<p>而在Java 13中，JEP 351再次对ZGC做了增强，本次 ZGC 可以将未使用的堆内存返回给操作系统。之所以引入这个特性，是因为如今有很多场景中内存是比较昂贵的资源，在以下情况中，将内存还给操作系统还是很有必要的：<br>1、那些需要根据使用量付费的容器<br>2、应用程序可能长时间处于空闲状态并与许多其他应用程序共享或竞争资源的环境。<br>3、应用程序在执行期间可能有非常不同的堆空间需求。例如，启动期间所需的堆可能大于稍后在稳定状态执行期间所需的堆。<br>Reimplement the Legacy Socket API<br>使用易于维护和调试的更简单、更现代的实现替换 java.net.Socket 和 java.net.ServerSocket API。<br>java.net.Socket和java.net.ServerSocket的实现非常古老，这个JEP为它们引入了一个现代的实现。现代实现是Java 13中的默认实现，但是旧的实现还没有删除，可以通过设置系统属性jdk.net.usePlainSocketImpl来使用它们。<br>运行一个实例化Socket和ServerSocket的类将显示这个调试输出。这是默认的(新的).</p>
<p> 上面输出的sun.nio.ch.NioSocketImpl就是新提供的实现。<br>如果使用旧的实现也是可以的（指定参数jdk.net.usePlainSocketImpl）：</p>
<p> 上面的结果中，旧的实现java.net.PlainSocketImpl被用到了。<br>Switch Expressions (Preview)<br>在JDK 12中引入了Switch表达式作为预览特性。JEP 354修改了这个特性，它引入了yield语句，用于返回值。这意味着，switch表达式(返回值)应该使用yield, switch语句(不返回值)应该使用break。<br>在以前，我们想要在switch中返回内容，还是比较麻烦的，一般语法如下：</p>
<p> 在JDK13中使用以下语法：</p>
<p> 或者</p>
<p> 在这之后，switch中就多了一个关键字用于跳出switch块了，那就是yield，他用于返回一个值。和return的区别在于：return会直接跳出当前循环或者方法，而yield只会跳出当前switch块。<br>Text Blocks (Preview)<br>在JDK 12中引入了Raw String Literals特性，但在发布之前就放弃了。这个JEP在引入多行字符串文字（text block）在意义上是类似的。<br>text block，文本块，是一个多行字符串文字，它避免了对大多数转义序列的需要，以可预测的方式自动格式化字符串，并在需要时让开发人员控制格式。<br>我们以前从外部copy一段文本串到Java中，会被自动转义，如有一段以下字符串：</p>
<p> 将其复制到Java的字符串中，会展示成以下内容：</p>
<p>使用“”“作为文本块的开始符合结束符，在其中就可以放置多行的字符串，不需要进行任何转义。看起来就十分清爽了。<br>如常见的SQL语句：</p>
<p> 看起来就比较直观，清爽了。</p>
<p>JDK13中包含的5个特性，能够改变开发者的编码风格的主要有Text Blocks和Switch Expressions两个新特性，但是这两个特性还处于预览阶段。<br>而且，JDK13并不是LTS（长期支持）版本，如果你正在使用Java 8（LTS）或者Java 11（LTS），暂时可以不必升级到Java 13.</p>
]]></content>
  </entry>
  <entry>
    <title>契约式编程与防御式编程</title>
    <url>/2020/10/21/%E5%A5%91%E7%BA%A6%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%98%B2%E5%BE%A1%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>事情的来由还要从几十几亿年前的一次星球大爆炸说起，sorry，背错台词了，是从几天前讨论接口返回数据和几个月前讨论课件本地数据结构说起，简单的说，就是碰到约定好的内容出现异常，是我们在程序中内部作兼容处理，还是抛出去。</p>
<p>打个比方，我们要解析一段json，约定这个json的格式，只能是正常格式，或者是空，那么一旦返回json的方法返回了一个『既不是正常格式，又不是空的异常值』，程序该如何处理呢？</p>
<p>小花：一旦碰到约定异常，程序必须兼容处理，一定不能让程序Crash<br>小Fa：一旦碰到约定异常，就必须抛出去，告知约定有误，找出具体错误原因</p>
<p>这个问题，相信只要是程序猿基本都遇到过，举个最常见的栗子，NullPointerException，假如我们要从json中取一个字段，突然发现发生了NullPointerException，一些开发者认为是数据问题，那么把json中的这个字段改正确就行了；还有一些开发者认为是程序问题，认为程序需要做非空判断，再去使用。我相信这两种程序猿都有自己的理由，第一种程序简洁明了，代码逻辑干净，但一旦出错，就会崩溃，第二种程序耐操，随你数据怎么错，我都能不Crash，但代码中到处存在非空判断，臃肿、重复。</p>
<p>生存还是毁灭，这是一个问题！</p>
<h2 id="防御式编程"><a href="#防御式编程" class="headerlink" title="防御式编程"></a>防御式编程</h2><p>就在我们为了这个问题而争论的时候，突然有一个姓康的同事，施法祭出了一块砖头（《代码大全2》，近900页，相当于3本《Android群英传》），我一度以为他想砸在我的脸上，正当我准备闪避的时候，他翻到了这块砖头的第八章，几个大字赫然印入了我的视线——『防御式编程』。<br><img src="1.jpeg" style="margin: 0 auto;"></p>
<p>果然是老司机，居然可以从防御性驾驶中悟出防御性编程，说好的编程不开车，开车不编程呢？</p>
<p>这位作者编程厉不厉害我不知道，但我知道，论开车，一定没有何老师diao！</p>
<p>OK，《代码大全》给我们提供了一个定义——『防御式编程』，说白了，就是『人类都是不安全、不值得信任的，所有的人，都会犯错误，而你写的代码，应该考虑到所有可能发生的错误，让你的程序不会因为他人的错误而发生错误』</p>
<p>在书中，作者告诉我们，程序需要对可能的错误输入，做出兼容，例如一个除法的函数，你必须判断分母可能为0的情况，从而给调用者返回错误提示。另外，一般的高级编程语言，都提供了『断言』和『异常』两种方式来进行错误处理。</p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>断言，是一种在开发阶段使用的，让程序在运行时进行自检的代码，断言为真，那么程序运行正常，断言为假，那么程序运行异常退出。等等，防御式编程不是说好的要兼容异常吗，为什么会退出？实际上，作者的意思是，先断言、后处理错误，而断言是在开发环境中的，正式上线后是不会有断言的。<br><img src="2.jpeg" style="margin: 0 auto;"></p>
<p>但实际上，这是一个悖论，开发阶段的错误处理代码在开发阶段被断言给拦截掉了，但错误处理代码也是人写的，那么如何去检测『错误处理代码可能发生的错误』呢？</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>当代码出现问题时，可以通过抛出异常来进行通知，如果你无法处理，则可以交给外界进行处理。这个不多说，毕竟大部分代码，如果有异常，最简单的就是try catch了，我甚至见过把所以代码直接try catch的，你是有多不相信人类。</p>
<p>所以我觉得防御式编程用久了，会不会开始怀疑人生，果然，在往后翻几页，作者也给出了建议。<br><img src="3.jpeg" style="margin: 0 auto;"></p>
<p>借用奇异博士的一句台词——『你TM居然把警告写在咒语的下一页』！</p>
<p>简而言之，防御式编程，就是持怀疑态度审视所有的代码，但这个和我们讨论的主题还是略有不同的，我们讨论的主题是『已经有了约定，但返回了约定之外的内容』。</p>
<h2 id="契约式编程"><a href="#契约式编程" class="headerlink" title="契约式编程"></a>契约式编程</h2><p>就在我们讨论的时候，天空突然飘来五个字——那都不是事，哦不对，是『契约式编程』。</p>
<p>这个好像有点像！我们先来简单的看下什么是契约式编程，简单的说，契约作用于两方，每一方都会完成一些任务，从而促成契约的达成，但同时，每一方也会接受一些义务，作为制定契约的前提，有任意一方无视了必尽义的义务，则契约失败。</p>
<p>契约式编程要求我们在『前提条件』、『后继条件』和『不变量条件』进行契约的检查。类似的，例如检查参数，一旦参数不对，当即撕毁契约。这一点，现在很多新的语言都支持了，例如Swift，就支持对参数进行约束检查，这就是一种类契约式编程。</p>
<p>契约所约束的，是『一个为了确保程序正常运行的条件』，一旦契约被损毁，只有一个原因，那就是程序出了Bug，例如一个数据字段，在我处理的时候，必须保证是不为空的，那么谁来保证这一点呢，一定是我的调用方（或者说是其它模块），所以，一旦出现问题，应该有调用方来检查，确保调用的时候，必须是不为空的。</p>
<p>这让我想到了刚开始在面向日本人编程时期的一些事，日本人的做事风格是出了名的谨慎和详细，每一个方法、函数，在详细设计的时候，就已经把参数、返回值，已经它们的类型和所有可能的值都设计好了，每个方法之间有着明确的界限，如果你的方法因为传入的参数不在设计范围内而导致错误，你完全可以去找调用方，要求他按照设计来进行调用。不得不说，这应该是契约编程的最佳实践。日企普遍使用这种方式其实还有一个原因，那就是可以严格区分责任，让每个人都不必为了迁就他人的错误而进行『艰难的编码』。每个人按照契约处理好自己的事情，让损毁契约的人承担责任。</p>
<p>再引申一下，这和现在的『面向接口编程』也非常类似，两个模块之间，定义好调用、处理的接口，而具体的实现，对方都不用关心，只要安装协议的接口来进行开发就可以了，但光有接口也不够，还需要契约来做进一步的约束，例如参数、返回值的约束。</p>
<p>无独有偶，在《代码大全》中，作者也提出了『进攻式编程』，其实和契约编程，有异曲同工之妙。<br><img src="4.jpeg" style="margin: 0 auto;"></p>
<h2 id="乌托邦"><a href="#乌托邦" class="headerlink" title="乌托邦"></a>乌托邦</h2><p>OK，梦醒了，让阳光照进现实。以上两种编程方式，都是非常理想化的编程，但在一般的公司里面不论是防御还是契约，实现起来都是比较困难的，例如前端与后端的接口、不同部门同事的交流，按照契约式编程，没人Care你的契约，按照防御式编程，代码惨不忍睹，还容易漏掉防御。那么到底该怎么办呢，我认为，如果能在公司层面推广契约式编程，首先是对开发效率的提升，让每个人都对自己写的代码负责，在开发者之间建立良好的信任关系，同时也能减少不必要的沟通成本和精力。但同时，必要的防御式编程也是不能少的，这是保证程序健壮、稳定的前提。怎么说呢，中国人民秉承了千百年的传统——『中庸之道』，契约还是防御，视情况而定，这是平衡的艺术。</p>
]]></content>
      <tags>
        <tag>契约式编程</tag>
        <tag>防御式编程</tag>
        <tag>编程思想2</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式/创建型模式/特点和分类</title>
    <url>/2020/10/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%89%B9%E7%82%B9%E5%92%8C%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>开发原则/开闭原则</title>
    <url>/2020/10/10/%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据 7 条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。我们将在下面的几节中依次来介绍这 7 条原则，本节首先介绍开闭原则。<br>开闭原则的定义<br>开闭原则（Open Closed Principle，OCP）由勃兰特·梅耶（Bertrand Meyer）提出，他在 1988 年的著作《面向对象软件构造》（Object Oriented Software Construction）中提出：软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义。</p>
<p>这里的软件实体包括以下几个部分：<br>项目中划分出的模块<br>类与接口<br>方法</p>
<p>开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。<br>开闭原则的作用<br>开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。</p>
<ol>
<li>对软件测试的影响<br>软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。</li>
<li>可以提高代码的可复用性<br>粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。</li>
<li>可以提高软件的可维护性<br>遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。<br>开闭原则的实现方法<br>可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</li>
</ol>
<p>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p>
<p>下面以 Windows 的桌面主题为例介绍开闭原则的应用。</p>
<p>【例1】Windows 的桌面主题设计。</p>
<p>分析：Windows 的主题是桌面背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的桌面主题，也可以从网上下载新的主题。这些主题有共同的特点，可以为其定义一个抽象类（Abstract Subject），而每个具体的主题（Specific Subject）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的，其类图如图 1 所示。<br><img src="2020-10-10-17-31-07.png" style="margin: 0 auto;"></p>
]]></content>
  </entry>
  <entry>
    <title>interview/java</title>
    <url>/2020/10/10/interview-java/</url>
    <content><![CDATA[<h2 id="java-基础"><a href="#java-基础" class="headerlink" title="java 基础"></a>java 基础</h2><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md</a></p>
<h2 id="Java-疑难点"><a href="#Java-疑难点" class="headerlink" title="Java 疑难点"></a>Java 疑难点</h2><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java%E7%96%91%E9%9A%BE%E7%82%B9.md">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java%E7%96%91%E9%9A%BE%E7%82%B9.md</a></p>
<h2 id="什么是-Java-虚拟机（JVM）？为什么-Java-被称作是“平台无关的编程语言”？"><a href="#什么是-Java-虚拟机（JVM）？为什么-Java-被称作是“平台无关的编程语言”？" class="headerlink" title="什么是 Java 虚拟机（JVM）？为什么 Java 被称作是“平台无关的编程语言”？"></a>什么是 Java 虚拟机（JVM）？为什么 Java 被称作是“平台无关的编程语言”？</h2><p>Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚拟机执行的字节码文件。</p>
<p>java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p>
<h2 id="JDK、JRE、JVM-分别是什么关系？"><a href="#JDK、JRE、JVM-分别是什么关系？" class="headerlink" title="JDK、JRE、JVM 分别是什么关系？"></a>JDK、JRE、JVM 分别是什么关系？</h2><p>JDK 即为 Java 开发工具包，包含编写 Java 程序所必须的编译、运行等开发工具以及 JRE。开发工具如：用于编译 Java 程序的 javac 命令、用于启动 JVM 运行 Java 程序的 Java 命令、用于生成文档的 Javadoc 命令以及用于打包的 jar 命令等等。</p>
<p>JRE 即为 Java 运行环境，提供了运行 Java 应用程序所必须的软件环境，包含有 Java 虚拟机（JVM）和丰富的系统类库。系统类库即为 Java 提前封装好的功能类，只需拿来直接使用即可，可以大大的提高开发效率。</p>
<p>JVM 即为 Java 虚拟机，提供了字节码文件（.class）的运行环境支持。 简单说，就是 JDK 包含 JRE 包含 JVM。</p>
<h2 id="Java-支持的数据类型有哪些？"><a href="#Java-支持的数据类型有哪些？" class="headerlink" title="Java 支持的数据类型有哪些？"></a>Java 支持的数据类型有哪些？</h2><p>Java 支持的数据类型包括基本数据类型和引用类型。基本数据类型如下。 整数值型：byte，short，int，long<br>字符型：char<br>浮点类型：float，double<br>布尔型：boolean<br>整数默认 int 型，小数默认是 double 型。Float 和 long 类型的必须加后缀。比如 float f = 100f。</p>
<p>首先知道 String 是引用类型不是基本类型，引用类型声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。引用类型包括类、接口、数组等。String 类还是 final 修饰的。</p>
<h2 id="什么是自动拆装箱？"><a href="#什么是自动拆装箱？" class="headerlink" title="什么是自动拆装箱？"></a>什么是自动拆装箱？</h2><p>自动装箱和拆箱就是基本类型和引用类型之间的转换，至于为什么要转换，因为基本类型转换为引用类型后，就可以 new 对象，从而调用包装类中封装好的方法进行基本类型之间的转换或者 toString（当然用类名直接调用也可以，便于一眼看出该方法是静态的），还有就是如果集合中想存放基本类型，泛型的限定类型只能是对应的包装类型。</p>
<h2 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h2><p>面向对象是一种思想，世间万物都可以看做一个对象，这里只讨论面向对象编程（OOP），Java 是一个支持并发、基于类和面向对象的计算机编程语言，面向对象软件开发具有以下优点：代码开发模块化，更易维护和修改；代码复用性强；增强代码的可靠性和灵活性；增加代码的可读性。</p>
<h2 id="面向对象的四大基本特性？"><a href="#面向对象的四大基本特性？" class="headerlink" title="面向对象的四大基本特性？"></a>面向对象的四大基本特性？</h2><p>抽象：提取现实世界中某事物的关键特性，为该事物构建模型的过程。对同一事物在不同的需求下，需要提取的特性可能不一样。得到的抽象模型中一般包含：属性（数据）和操作（行为）。这个抽象模型我们称之为类，对类进行实例化得到对象。</p>
<p>封装：封装可以使类具有独立性和隔离性，保证类的高内聚。只暴露给类外部或者子类必须的属性和操作。类封装的实现依赖类的修饰符（public、protected 和 private 等）。</p>
<p>继承：对现有类的一种复用机制。一个类如果继承现有的类，则这个类将拥有被继承类的所有非私有特性（属性和操作）。这里指的继承包含：类的继承和接口的实现。</p>
<p>多态：多态是在继承的基础上实现的。多态的三个要素：继承、重写和父类引用指向子类对象。父类引用指向不同的子类对象时，调用相同的方法，呈现出不同的行为，就是类多态特性。多态可以分成编译时多态和运行时多态。</p>
<p>抽象、封装、继承和多态是面向对象的基础。</p>
<h2 id="amp-与-amp-amp-的区别？"><a href="#amp-与-amp-amp-的区别？" class="headerlink" title="&amp; 与 &amp;&amp; 的区别？"></a>&amp; 与 &amp;&amp; 的区别？</h2><p>&amp; 运算符有两种用法：(1) 按位与，(2) 逻辑与。&amp;&amp; 运算符是短路与运算。</p>
<p>逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是 true。&amp;&amp; 之所以称为短路运算是因为，如果 &amp;&amp; 左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</p>
<p>很多时候我们可能都需要用 &amp;&amp; 而不是 &amp;，例如在验证用户登录时判定用户名不是 null 而且不是空字符串，应当写为：</p>
<p>username != null &amp;&amp; !username.equals(“”)</p>
<p>二者的顺序不能交换，更不能用 &amp; 运算符，因为第一个条件如果不成立，根本不能进行字符串的 equals 比较，否则会产生 NullPointerException 异常。</p>
<p>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p>
<h2 id="什么是值传递和引用传递？"><a href="#什么是值传递和引用传递？" class="headerlink" title="什么是值传递和引用传递？"></a>什么是值传递和引用传递？</h2><p>值传递是对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。</p>
<p>引用传递一般是对于对象型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身。一般认为，Java 内的传递都是值传递，Java 中实例对象的传递是引用传递。</p>
<p>是否可以在 static 环境中访问非 static 变量？</p>
<p>static 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机载入的时候，会对 static 变量进行初始化。如果你的代码尝试不用实例来访问非 static 的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p>
<p>Java 中的方法覆盖（Overriding）和方法重载（Overloading）是什么意思？</p>
<p>Java 中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。</p>
<h2 id="Java-支持多继承么？"><a href="#Java-支持多继承么？" class="headerlink" title="Java 支持多继承么？"></a>Java 支持多继承么？</h2><p>Java 中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是 Java 中的接口支持多继承，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。</p>
<h2 id="Java-中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"><a href="#Java-中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？" class="headerlink" title="Java 中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"></a>Java 中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？</h2><p>当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java 编译器会为这个类创建一个默认的构造方法。</p>
<p>Java 中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。</p>
<p>Java 不支持像 C++ 中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java 不会创建默认的复制构造方法。</p>
<h2 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a>接口和抽象类的区别是什么？</h2><p>从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p>
<p>Java 提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于： 接口中所有的方法隐含的都是抽象的，而抽象类则可以同时包含抽象和非抽象的方法。</p>
<p>类可以实现很多个接口，但是只能继承一个抽象类。类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</p>
<p>抽象类可以在不提供接口方法实现的情况下实现接口。 Java 接口中声明的变量默认都是 final 的。抽象类可以包含非 final 的变量。Java 接口中的成员函数默认是 public 的。抽象类的成员函数可以是 private，protected 或者是 public。</p>
<p>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含 main 方法的话是可以被调用的。也可以参考 JDK8 中抽象类和接口的区别。</p>
<h2 id="用最有效率的方法计算-2-乘以-8？"><a href="#用最有效率的方法计算-2-乘以-8？" class="headerlink" title="用最有效率的方法计算 2 乘以 8？"></a>用最有效率的方法计算 2 乘以 8？</h2><p>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。</p>
<h2 id="手写单例模式（饿汉和懒汉模式）和工厂模式？"><a href="#手写单例模式（饿汉和懒汉模式）和工厂模式？" class="headerlink" title="手写单例模式（饿汉和懒汉模式）和工厂模式？"></a>手写单例模式（饿汉和懒汉模式）和工厂模式？</h2><p>饿汉模式<br>//饿汉式单例类.在类初始化时，已经自行实例化<br>public class Singleton1 {<br>//私有的默认构造子<br>private Singleton1() {}<br>//已经自行实例化<br>private static final Singleton1 single = new Singleton1();<br>//静态工厂方法<br>public static Singleton1 getInstance() {<br>return single;<br>}<br>} 懒汉模式<br>//懒汉式单例类.在第一次调用的时候实例化<br>public class Singleton2 {<br>//私有的默认构造子<br>private Singleton2() {}<br>//注意，这里没有 final<br>private static Singleton2 single=null;<br>//静态工厂方法<br>public synchronized static Singleton2 getInstance() {<br>if (single == null) {<br>single = new Singleton2();<br>}<br>return single;<br>}<br>}<br>工厂模式，也可以参考之前的设计模式中的工厂模式，文末有链接。<br>interface IFactory{<br>public IProduct createProduct();<br>}<br>Class Factory implements IFactory{<br>public IProduct createProduct()<br>{<br>return new Product();<br>}<br>}<br>Public class client{<br>Public Static void main (String [] args){<br>IFactory factory=new Factory();<br>IProduct product=factory.createProduct();<br>product.ProductMethod();<br>}<br>}</p>
<h2 id="String-和-StringBuilder、StringBuffer-的区别？"><a href="#String-和-StringBuilder、StringBuffer-的区别？" class="headerlink" title="String 和 StringBuilder、StringBuffer 的区别？"></a>String 和 StringBuilder、StringBuffer 的区别？</h2><p>Java 平台提供了两种类型的字符串：String 和 StringBuffer/StringBuilder，它们可以储存和操作字符串。</p>
<p>其中 String 是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的。</p>
<p>而 StringBuffer/StringBuilder 类表示的字符串对象可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被 synchronized 修饰，因此它的效率也比 StringBuffer 要高。</p>
<h2 id="Java-集合框架有哪些？说出一些集合框架的优点？"><a href="#Java-集合框架有哪些？说出一些集合框架的优点？" class="headerlink" title="Java 集合框架有哪些？说出一些集合框架的优点？"></a>Java 集合框架有哪些？说出一些集合框架的优点？</h2><p>每种编程语言中都有集合，最初的 Java 版本包含几种集合类：Vector、Stack、HashTable 和 Array。随着集合的广泛使用，Java1.2 提出了囊括所有集合接口、实现和算法的集合框架。在保证线程安全的情况下使用泛型和并发集合类，Java 已经经历了很久。它还包括在 Java 并发包中，阻塞接口以及它们的实现。集合框架的部分优点如下： （1）使用核心集合类降低开发成本，而非实现我们自己的集合类。 （2）随着使用经过严格测试的集合框架类，代码质量会得到提高。 （3）通过使用 JDK 附带的集合类，可以降低代码维护成本。 （4）复用性和可操作性。</p>
<h2 id="集合框架中的泛型有什么优点？"><a href="#集合框架中的泛型有什么优点？" class="headerlink" title="集合框架中的泛型有什么优点？"></a>集合框架中的泛型有什么优点？</h2><p>Java1.5 引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型。因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现 ClassCastException，因为你将会在编译时得到报错信息。泛型也使得代码整洁，我们不需要使用显式转换和 instanceOf 操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令。</p>
<h2 id="Java-集合框架的基础接口有哪些？"><a href="#Java-集合框架的基础接口有哪些？" class="headerlink" title="Java 集合框架的基础接口有哪些？"></a>Java 集合框架的基础接口有哪些？</h2><p>Collection 为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java 平台不提供这个接口任何直接的实现。</p>
<p>Set 是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合，就如一副牌。</p>
<p>List 是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List 更像长度动态变换的数组。</p>
<p>Map 是一个将 key 映射到 value 的对象。一个 Map 不能包含重复的 key，每个 key 最多只能映射一个 value。</p>
<p>一些其它的接口有 Queue、Dequeue、SortedSet、SortedMap 和 ListIterator。</p>
<h2 id="为何-Collection-不从-Cloneable-和-Serializable-接口继承？"><a href="#为何-Collection-不从-Cloneable-和-Serializable-接口继承？" class="headerlink" title="为何 Collection 不从 Cloneable 和 Serializable 接口继承？"></a>为何 Collection 不从 Cloneable 和 Serializable 接口继承？</h2><p>Collection 接口指定一组对象，对象即为它的元素。如何维护这些元素由 Collection 的具体实现决定。例如，一些如 List 的 Collection 实现允许重复的元素，而其它的如 Set 就不允许。很多 Collection 实现有一个公有的 clone 方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为 Collection 是一个抽象表现，重要的是实现。</p>
<p>当与具体实现打交道的时候，克隆或序列化的语义和含义才发挥作用。所以，具体实现应该决定如何对它进行克隆或序列化，或它是否可以被克隆或序列化。在所有的实现中授权克隆和序列化，最终导致更少的灵活性和更多的限制，特定的实现应该决定它是否可以被克隆和序列化。</p>
<h2 id="为何-Map-接口不继承-Collection-接口？"><a href="#为何-Map-接口不继承-Collection-接口？" class="headerlink" title="为何 Map 接口不继承 Collection 接口？"></a>为何 Map 接口不继承 Collection 接口？</h2><p>尽管 Map 接口和它的实现也是集合框架的一部分，但 Map 不是集合，集合也不是 Map。因此，Map 继承 Collection 毫无意义，反之亦然。</p>
<p>如果 Map 继承 Collection 接口，那么元素去哪儿？Map 包含 key-value 对，它提供抽取 key 或 value 列表集合的方法，但是它不适合“一组对象”规范。</p>
<h2 id="什么是迭代器-Iterator-？"><a href="#什么是迭代器-Iterator-？" class="headerlink" title="什么是迭代器(Iterator)？"></a>什么是迭代器(Iterator)？</h2><p>Iterator 接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的 remove(Object Obj) 删除，可以通过迭代器的 remove() 方法删除。</p>
<h2 id="Iterator-和-ListIterator-的区别是什么？"><a href="#Iterator-和-ListIterator-的区别是什么？" class="headerlink" title="Iterator 和 ListIterator 的区别是什么？"></a>Iterator 和 ListIterator 的区别是什么？</h2><p>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。</p>
<p>Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。</p>
<p>ListIterator 实现了 Iterator 接口，并包含其他的功能。比如：增加元素，替换元素，获取前一个和后一个元素的索引等等。</p>
<h2 id="Java-中的-HashMap-的工作原理是什么？"><a href="#Java-中的-HashMap-的工作原理是什么？" class="headerlink" title="Java 中的 HashMap 的工作原理是什么？"></a>Java 中的 HashMap 的工作原理是什么？</h2><p>我们知道在 Java 中最常用的两种结构是数组和模拟指针（引用），几乎所有的数据结构都可以利用这两种来组合实现，HashMap 也是如此。实际上 HashMap 是一个“链表散列”。</p>
<p>HashMap 是基于 hashing 的原理，我们使用 put(key, value) 存储对象到 HashMap 中，使用 get(key) 从 HashMap 中获取对象。当我们给 put() 方法传递键和值时，我们先对键调用 hashCode() 方法，返回的 hashCode 用于找到 bucket 位置来储存 Entry 对象。</p>
<h2 id="当两个对象的-hashcode-相同会发生什么？"><a href="#当两个对象的-hashcode-相同会发生什么？" class="headerlink" title="当两个对象的 hashcode 相同会发生什么？"></a>当两个对象的 hashcode 相同会发生什么？</h2><p>因为 hashcode 相同，所以它们的 bucket 位置相同，“碰撞”会发生。因为 HashMap 使用链表存储对象，这个 Entry（包含有键值对的 Map.Entry 对象）会存储在链表中。</p>
<h2 id="如果两个键的-hashcode-相同，你如何获取值对象？"><a href="#如果两个键的-hashcode-相同，你如何获取值对象？" class="headerlink" title="如果两个键的 hashcode 相同，你如何获取值对象？"></a>如果两个键的 hashcode 相同，你如何获取值对象？</h2><p>当我们调用 get() 方法，HashMap 会使用键对象的 hashcode 找到 bucket 位置，然后会调用 keys.equals() 方法去找到链表中正确的节点，最终找到要找的值对象。</p>
<h2 id="hashCode-和-equals-方法有何重要性？"><a href="#hashCode-和-equals-方法有何重要性？" class="headerlink" title="hashCode() 和 equals() 方法有何重要性？"></a>hashCode() 和 equals() 方法有何重要性？</h2><p>HashMap 使用 Key 对象的 hashCode() 和 equals() 方法去决定 key-value 对的索引。当我们试着从 HashMap 中获取值的时候，这些方法也会被用到。</p>
<p>如果这些方法没有被正确地实现，在这种情况下，两个不同 Key 也许会产生相同的 hashCode() 和 equals() 输出，HashMap 将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。</p>
<p>同样的，所有不允许存储重复数据的集合类都使用 hashCode() 和 equals() 去查找重复，所以正确实现它们非常重要。equals() 和 hashCode() 的实现应该遵循以下规则：</p>
<p>如果 o1.equals(o2)，那么 o1.hashCode() == o2.hashCode()总是为 true 的。 如果 o1.hashCode() == o2.hashCode()，并不意味着 o1.equals(o2)会为 true。</p>
<h2 id="HashMap-和-HashTable-有什么区别？"><a href="#HashMap-和-HashTable-有什么区别？" class="headerlink" title="HashMap 和 HashTable 有什么区别？"></a>HashMap 和 HashTable 有什么区别？</h2><p>HashMap 是非线程安全的，HashTable 是线程安全的。<br>HashMap 的键和值都允许有 null 值存在，而 HashTable 则不行。<br>因为线程安全的问题，HashMap 效率比 HashTable 的要高。<br>HashTable 是同步的，而 HashMap 不是。因此，HashMap 更适合于单线程环境，而 HashTable 适合于多线程环境。<br>一般现在不建议用 HashTable，一是 HashTable 是遗留类，内部实现很多没优化和冗余。二是即使在多线程环境下，现在也有同步的 ConcurrentHashMap 替代，没有必要因为是多线程而用 HashTable。</p>
<h2 id="如何决定选用-HashMap-还是-TreeMap？"><a href="#如何决定选用-HashMap-还是-TreeMap？" class="headerlink" title="如何决定选用 HashMap 还是 TreeMap？"></a>如何决定选用 HashMap 还是 TreeMap？</h2><p>对于在 Map 中插入、删除和定位元素这类操作，HashMap 是最好的选择。然而，假如你需要对一个有序的 key 集合进行遍历， TreeMap 是更好的选择。基于你的 collection 的大小，也许向 HashMap 中添加元素会更快，将 map 换为 TreeMap 进行有序 key 的遍历。</p>
<h2 id="ArrayList-和-Vector-有何异同点？"><a href="#ArrayList-和-Vector-有何异同点？" class="headerlink" title="ArrayList 和 Vector 有何异同点？"></a>ArrayList 和 Vector 有何异同点？</h2><p>ArrayList 和 Vector 在很多时候都很类似。<br>（1）两者都是基于索引的，内部由一个数组支持。<br>（2）两者维护插入的顺序，我们可以根据插入顺序来获取元素。<br>（3）ArrayList 和 Vector 的迭代器实现都是 fail-fast 的。<br>（4）ArrayList 和 Vector 两者允许 null 值，也可以使用索引值对元素进行随机访问。<br>以下是 ArrayList 和 Vector 的不同点。<br>（1）Vector 是同步的，而 ArrayList 不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用 CopyOnWriteArrayList。<br>（2）ArrayList 比 Vector 快，它因为有同步，不会过载。<br>（3）ArrayList 更加通用，因为我们可以使用 Collections 工具类轻易地获取同步列表和只读列表。</p>
<h2 id="Array-和-ArrayList-有何区别？什么时候更适合用-Array？"><a href="#Array-和-ArrayList-有何区别？什么时候更适合用-Array？" class="headerlink" title="Array 和 ArrayList 有何区别？什么时候更适合用 Array？"></a>Array 和 ArrayList 有何区别？什么时候更适合用 Array？</h2><p>Array 可以容纳基本类型和对象，而 ArrayList 只能容纳对象。 Array 是指定大小的，而 ArrayList 大小是固定的。Array 没有提供 ArrayList 那么多功能，比如 addAll、removeAll 和 iterator 等。尽管 ArrayList 明显是更好的选择，但也有些时候 Array 比较好用，比如下面的三种情况。<br>（1）如果列表的大小已经指定，大部分情况下是存储和遍历它们。<br>（2）对于遍历基本数据类型，尽管 Collections 使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。<br>（3）如果你要使用多维数组，使用 [][] 比 List。</p>
<h2 id="快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？"><a href="#快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？" class="headerlink" title="快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？"></a>快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？</h2><p>快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个 ConcurrentModification 异常。 在 java.util 包下的都是快速失败。</p>
<p>安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出 ConcurrentModification 异常。在 java.util.concurrent 包下的全是安全失败的。</p>
<h1 id="一、java基础面试知识点"><a href="#一、java基础面试知识点" class="headerlink" title="一、java基础面试知识点"></a>一、java基础面试知识点</h1><h2 id="java中-和equals和hashCode的区别"><a href="#java中-和equals和hashCode的区别" class="headerlink" title="java中==和equals和hashCode的区别"></a>java中==和equals和hashCode的区别</h2><h2 id="int、char、long各占多少字节数"><a href="#int、char、long各占多少字节数" class="headerlink" title="int、char、long各占多少字节数"></a>int、char、long各占多少字节数</h2><h2 id="int与integer的区别"><a href="#int与integer的区别" class="headerlink" title="int与integer的区别"></a>int与integer的区别</h2><h2 id="探探对java多态的理解"><a href="#探探对java多态的理解" class="headerlink" title="探探对java多态的理解"></a>探探对java多态的理解</h2><h2 id="String、StringBuffer、StringBuilder区别"><a href="#String、StringBuffer、StringBuilder区别" class="headerlink" title="String、StringBuffer、StringBuilder区别"></a>String、StringBuffer、StringBuilder区别</h2><h2 id="什么是内部类？内部类的作用"><a href="#什么是内部类？内部类的作用" class="headerlink" title="什么是内部类？内部类的作用"></a>什么是内部类？内部类的作用</h2><h2 id="抽象类和接口区别"><a href="#抽象类和接口区别" class="headerlink" title="抽象类和接口区别"></a>抽象类和接口区别</h2><h2 id="抽象类的意义"><a href="#抽象类的意义" class="headerlink" title="抽象类的意义"></a>抽象类的意义</h2><h2 id="抽象类与接口的应用场景"><a href="#抽象类与接口的应用场景" class="headerlink" title="抽象类与接口的应用场景"></a>抽象类与接口的应用场景</h2><h2 id="抽象类是否可以没有方法和属性？"><a href="#抽象类是否可以没有方法和属性？" class="headerlink" title="抽象类是否可以没有方法和属性？"></a>抽象类是否可以没有方法和属性？</h2><h2 id="接口的意义"><a href="#接口的意义" class="headerlink" title="接口的意义"></a>接口的意义</h2><h2 id="泛型中extends和super的区别"><a href="#泛型中extends和super的区别" class="headerlink" title="泛型中extends和super的区别"></a>泛型中extends和super的区别</h2><h2 id="父类的静态方法能否被子类重写"><a href="#父类的静态方法能否被子类重写" class="headerlink" title="父类的静态方法能否被子类重写"></a>父类的静态方法能否被子类重写</h2><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><h2 id="final，finally，finalize的区别"><a href="#final，finally，finalize的区别" class="headerlink" title="final，finally，finalize的区别"></a>final，finally，finalize的区别</h2><h2 id="序列化的方式"><a href="#序列化的方式" class="headerlink" title="序列化的方式"></a>序列化的方式</h2><h2 id="Serializable-和Parcelable-的区别"><a href="#Serializable-和Parcelable-的区别" class="headerlink" title="Serializable 和Parcelable 的区别"></a>Serializable 和Parcelable 的区别</h2><h2 id="静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？"><a href="#静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？" class="headerlink" title="静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？"></a>静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</h2><h2 id="静态内部类的设计意图"><a href="#静态内部类的设计意图" class="headerlink" title="静态内部类的设计意图"></a>静态内部类的设计意图</h2><h2 id="成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用"><a href="#成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用" class="headerlink" title="成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用"></a>成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用</h2><h2 id="谈谈对kotlin的理解"><a href="#谈谈对kotlin的理解" class="headerlink" title="谈谈对kotlin的理解"></a>谈谈对kotlin的理解</h2><h2 id="闭包和局部内部类的区别"><a href="#闭包和局部内部类的区别" class="headerlink" title="闭包和局部内部类的区别"></a>闭包和局部内部类的区别</h2><h2 id="string-转换成-integer的方式及原理"><a href="#string-转换成-integer的方式及原理" class="headerlink" title="string 转换成 integer的方式及原理"></a>string 转换成 integer的方式及原理</h2><h1 id="二、java深入源码级的面试题（有难度）"><a href="#二、java深入源码级的面试题（有难度）" class="headerlink" title="二、java深入源码级的面试题（有难度）"></a>二、java深入源码级的面试题（有难度）</h1><h2 id="哪些情况下的对象会被垃圾回收机制处理掉？"><a href="#哪些情况下的对象会被垃圾回收机制处理掉？" class="headerlink" title="哪些情况下的对象会被垃圾回收机制处理掉？"></a>哪些情况下的对象会被垃圾回收机制处理掉？</h2><h2 id="讲一下常见编码方式？"><a href="#讲一下常见编码方式？" class="headerlink" title="讲一下常见编码方式？"></a>讲一下常见编码方式？</h2><h2 id="utf-8编码中的中文占几个字节；int型几个字节？"><a href="#utf-8编码中的中文占几个字节；int型几个字节？" class="headerlink" title="utf-8编码中的中文占几个字节；int型几个字节？"></a>utf-8编码中的中文占几个字节；int型几个字节？</h2><h2 id="静态代理和动态代理的区别，什么场景使用？"><a href="#静态代理和动态代理的区别，什么场景使用？" class="headerlink" title="静态代理和动态代理的区别，什么场景使用？"></a>静态代理和动态代理的区别，什么场景使用？</h2><h2 id="Java的异常体系"><a href="#Java的异常体系" class="headerlink" title="Java的异常体系"></a>Java的异常体系</h2><h2 id="谈谈你对解析与分派的认识。"><a href="#谈谈你对解析与分派的认识。" class="headerlink" title="谈谈你对解析与分派的认识。"></a>谈谈你对解析与分派的认识。</h2><h2 id="修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法？"><a href="#修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法？" class="headerlink" title="修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法？"></a>修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法？</h2><h2 id="Java中实现多态的机制是什么？"><a href="#Java中实现多态的机制是什么？" class="headerlink" title="Java中实现多态的机制是什么？"></a>Java中实现多态的机制是什么？</h2><h2 id="如何将一个Java对象序列化到文件里？"><a href="#如何将一个Java对象序列化到文件里？" class="headerlink" title="如何将一个Java对象序列化到文件里？"></a>如何将一个Java对象序列化到文件里？</h2><h2 id="说说你对Java反射的理解"><a href="#说说你对Java反射的理解" class="headerlink" title="说说你对Java反射的理解"></a>说说你对Java反射的理解</h2><h2 id="说说你对Java注解的理解"><a href="#说说你对Java注解的理解" class="headerlink" title="说说你对Java注解的理解"></a>说说你对Java注解的理解</h2><h2 id="说说你对依赖注入的理解"><a href="#说说你对依赖注入的理解" class="headerlink" title="说说你对依赖注入的理解"></a>说说你对依赖注入的理解</h2><h2 id="说一下泛型原理，并举例说明"><a href="#说一下泛型原理，并举例说明" class="headerlink" title="说一下泛型原理，并举例说明"></a>说一下泛型原理，并举例说明</h2><h2 id="Java中String的了解"><a href="#Java中String的了解" class="headerlink" title="Java中String的了解"></a>Java中String的了解</h2><h2 id="String为什么要设计成不可变的？"><a href="#String为什么要设计成不可变的？" class="headerlink" title="String为什么要设计成不可变的？"></a>String为什么要设计成不可变的？</h2><h2 id="Object类的equal和hashCode方法重写，为什么？"><a href="#Object类的equal和hashCode方法重写，为什么？" class="headerlink" title="Object类的equal和hashCode方法重写，为什么？"></a>Object类的equal和hashCode方法重写，为什么？</h2><h1 id="三、数据结构"><a href="#三、数据结构" class="headerlink" title="三、数据结构"></a>三、数据结构</h1><h2 id="常用数据结构简介"><a href="#常用数据结构简介" class="headerlink" title="常用数据结构简介"></a>常用数据结构简介</h2><h2 id="并发集合了解哪些？"><a href="#并发集合了解哪些？" class="headerlink" title="并发集合了解哪些？"></a>并发集合了解哪些？</h2><h2 id="列举java的集合以及集合之间的继承关系"><a href="#列举java的集合以及集合之间的继承关系" class="headerlink" title="列举java的集合以及集合之间的继承关系"></a>列举java的集合以及集合之间的继承关系</h2><h2 id="集合类以及集合框架"><a href="#集合类以及集合框架" class="headerlink" title="集合类以及集合框架"></a>集合类以及集合框架</h2><h2 id="容器类介绍以及之间的区别（容器类估计很多人没听这个词，Java容器主要可以划分为4个部分：List列表、Set集合、Map映射、工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections），具体的可以看看这篇博文-Java容器类）"><a href="#容器类介绍以及之间的区别（容器类估计很多人没听这个词，Java容器主要可以划分为4个部分：List列表、Set集合、Map映射、工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections），具体的可以看看这篇博文-Java容器类）" class="headerlink" title="容器类介绍以及之间的区别（容器类估计很多人没听这个词，Java容器主要可以划分为4个部分：List列表、Set集合、Map映射、工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections），具体的可以看看这篇博文 Java容器类）"></a>容器类介绍以及之间的区别（容器类估计很多人没听这个词，Java容器主要可以划分为4个部分：List列表、Set集合、Map映射、工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections），具体的可以看看这篇博文 Java容器类）</h2><h2 id="List-Set-Map的区别"><a href="#List-Set-Map的区别" class="headerlink" title="List,Set,Map的区别"></a>List,Set,Map的区别</h2><h2 id="List和Map的实现方式以及存储方式"><a href="#List和Map的实现方式以及存储方式" class="headerlink" title="List和Map的实现方式以及存储方式"></a>List和Map的实现方式以及存储方式</h2><h2 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h2><h2 id="HashMap数据结构？"><a href="#HashMap数据结构？" class="headerlink" title="HashMap数据结构？"></a>HashMap数据结构？</h2><h2 id="HashMap源码理解"><a href="#HashMap源码理解" class="headerlink" title="HashMap源码理解"></a>HashMap源码理解</h2><h2 id="HashMap如何put数据（从HashMap源码角度讲解）？"><a href="#HashMap如何put数据（从HashMap源码角度讲解）？" class="headerlink" title="HashMap如何put数据（从HashMap源码角度讲解）？"></a>HashMap如何put数据（从HashMap源码角度讲解）？</h2><h2 id="HashMap怎么手写实现？"><a href="#HashMap怎么手写实现？" class="headerlink" title="HashMap怎么手写实现？"></a>HashMap怎么手写实现？</h2><h2 id="ConcurrentHashMap的实现原理"><a href="#ConcurrentHashMap的实现原理" class="headerlink" title="ConcurrentHashMap的实现原理"></a>ConcurrentHashMap的实现原理</h2><h2 id="ArrayMap和HashMap的对比"><a href="#ArrayMap和HashMap的对比" class="headerlink" title="ArrayMap和HashMap的对比"></a>ArrayMap和HashMap的对比</h2><h2 id="HashTable实现原理"><a href="#HashTable实现原理" class="headerlink" title="HashTable实现原理"></a>HashTable实现原理</h2><h2 id="TreeMap具体实现"><a href="#TreeMap具体实现" class="headerlink" title="TreeMap具体实现"></a>TreeMap具体实现</h2><h2 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h2><h2 id="HashMap与HashSet的区别"><a href="#HashMap与HashSet的区别" class="headerlink" title="HashMap与HashSet的区别"></a>HashMap与HashSet的区别</h2><h2 id="HashSet与HashMap怎么判断集合元素重复？"><a href="#HashSet与HashMap怎么判断集合元素重复？" class="headerlink" title="HashSet与HashMap怎么判断集合元素重复？"></a>HashSet与HashMap怎么判断集合元素重复？</h2><h2 id="集合Set实现Hash怎么防止碰撞"><a href="#集合Set实现Hash怎么防止碰撞" class="headerlink" title="集合Set实现Hash怎么防止碰撞"></a>集合Set实现Hash怎么防止碰撞</h2><h2 id="ArrayList和LinkedList的区别，以及应用场景"><a href="#ArrayList和LinkedList的区别，以及应用场景" class="headerlink" title="ArrayList和LinkedList的区别，以及应用场景"></a>ArrayList和LinkedList的区别，以及应用场景</h2><h2 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h2><h2 id="二叉树的深度优先遍历和广度优先遍历的具体实现"><a href="#二叉树的深度优先遍历和广度优先遍历的具体实现" class="headerlink" title="二叉树的深度优先遍历和广度优先遍历的具体实现"></a>二叉树的深度优先遍历和广度优先遍历的具体实现</h2><h2 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h2><h2 id="堆和树的区别"><a href="#堆和树的区别" class="headerlink" title="堆和树的区别"></a>堆和树的区别</h2><h2 id="堆和栈在内存中的区别是什么-解答提示：可以从数据结构方面以及实际实现方面两个方面去回答-？"><a href="#堆和栈在内存中的区别是什么-解答提示：可以从数据结构方面以及实际实现方面两个方面去回答-？" class="headerlink" title="堆和栈在内存中的区别是什么(解答提示：可以从数据结构方面以及实际实现方面两个方面去回答)？"></a>堆和栈在内存中的区别是什么(解答提示：可以从数据结构方面以及实际实现方面两个方面去回答)？</h2><h2 id="什么是深拷贝和浅拷贝"><a href="#什么是深拷贝和浅拷贝" class="headerlink" title="什么是深拷贝和浅拷贝"></a>什么是深拷贝和浅拷贝</h2><h2 id="手写链表逆序代码"><a href="#手写链表逆序代码" class="headerlink" title="手写链表逆序代码"></a>手写链表逆序代码</h2><h2 id="讲一下对树，B-树的理解"><a href="#讲一下对树，B-树的理解" class="headerlink" title="讲一下对树，B+树的理解"></a>讲一下对树，B+树的理解</h2><h2 id="讲一下对图的理解"><a href="#讲一下对图的理解" class="headerlink" title="讲一下对图的理解"></a>讲一下对图的理解</h2><h2 id="判断单链表成环与否？"><a href="#判断单链表成环与否？" class="headerlink" title="判断单链表成环与否？"></a>判断单链表成环与否？</h2><h2 id="链表翻转（即：翻转一个单项链表）"><a href="#链表翻转（即：翻转一个单项链表）" class="headerlink" title="链表翻转（即：翻转一个单项链表）"></a>链表翻转（即：翻转一个单项链表）</h2><h2 id="合并多个单有序链表（假设都是递增的）"><a href="#合并多个单有序链表（假设都是递增的）" class="headerlink" title="合并多个单有序链表（假设都是递增的）"></a>合并多个单有序链表（假设都是递增的）</h2><h2 id="四、线程、多线程和线程池"><a href="#四、线程、多线程和线程池" class="headerlink" title="四、线程、多线程和线程池"></a>四、线程、多线程和线程池</h2><h2 id="开启线程的三种方式？"><a href="#开启线程的三种方式？" class="headerlink" title="开启线程的三种方式？"></a>开启线程的三种方式？</h2><h2 id="线程和进程的区别？"><a href="#线程和进程的区别？" class="headerlink" title="线程和进程的区别？"></a>线程和进程的区别？</h2><h2 id="为什么要有线程，而不是仅仅用进程？"><a href="#为什么要有线程，而不是仅仅用进程？" class="headerlink" title="为什么要有线程，而不是仅仅用进程？"></a>为什么要有线程，而不是仅仅用进程？</h2><h2 id="run-和start-方法区别"><a href="#run-和start-方法区别" class="headerlink" title="run()和start()方法区别"></a>run()和start()方法区别</h2><h2 id="如何控制某个方法允许并发访问线程的个数？"><a href="#如何控制某个方法允许并发访问线程的个数？" class="headerlink" title="如何控制某个方法允许并发访问线程的个数？"></a>如何控制某个方法允许并发访问线程的个数？</h2><h2 id="在Java中wait和seelp方法的不同；"><a href="#在Java中wait和seelp方法的不同；" class="headerlink" title="在Java中wait和seelp方法的不同；"></a>在Java中wait和seelp方法的不同；</h2><h2 id="谈谈wait-notify关键字的理解"><a href="#谈谈wait-notify关键字的理解" class="headerlink" title="谈谈wait/notify关键字的理解"></a>谈谈wait/notify关键字的理解</h2><h2 id="什么导致线程阻塞？"><a href="#什么导致线程阻塞？" class="headerlink" title="什么导致线程阻塞？"></a>什么导致线程阻塞？</h2><h2 id="线程如何关闭？"><a href="#线程如何关闭？" class="headerlink" title="线程如何关闭？"></a>线程如何关闭？</h2><h2 id="讲一下java中的同步的方法"><a href="#讲一下java中的同步的方法" class="headerlink" title="讲一下java中的同步的方法"></a>讲一下java中的同步的方法</h2><h2 id="数据一致性如何保证？"><a href="#数据一致性如何保证？" class="headerlink" title="数据一致性如何保证？"></a>数据一致性如何保证？</h2><h2 id="如何保证线程安全？"><a href="#如何保证线程安全？" class="headerlink" title="如何保证线程安全？"></a>如何保证线程安全？</h2><h2 id="如何实现线程同步？"><a href="#如何实现线程同步？" class="headerlink" title="如何实现线程同步？"></a>如何实现线程同步？</h2><h2 id="两个进程同时要求写或者读，能不能实现？如何防止进程的同步？"><a href="#两个进程同时要求写或者读，能不能实现？如何防止进程的同步？" class="headerlink" title="两个进程同时要求写或者读，能不能实现？如何防止进程的同步？"></a>两个进程同时要求写或者读，能不能实现？如何防止进程的同步？</h2><h2 id="线程间操作List"><a href="#线程间操作List" class="headerlink" title="线程间操作List"></a>线程间操作List</h2><h2 id="Java中对象的生命周期"><a href="#Java中对象的生命周期" class="headerlink" title="Java中对象的生命周期"></a>Java中对象的生命周期</h2><h2 id="Synchronized用法"><a href="#Synchronized用法" class="headerlink" title="Synchronized用法"></a>Synchronized用法</h2><h2 id="synchronize的原理"><a href="#synchronize的原理" class="headerlink" title="synchronize的原理"></a>synchronize的原理</h2><h2 id="谈谈对Synchronized关键字，类锁，方法锁，重入锁的理解"><a href="#谈谈对Synchronized关键字，类锁，方法锁，重入锁的理解" class="headerlink" title="谈谈对Synchronized关键字，类锁，方法锁，重入锁的理解"></a>谈谈对Synchronized关键字，类锁，方法锁，重入锁的理解</h2><h2 id="static-synchronized-方法的多线程访问和作用"><a href="#static-synchronized-方法的多线程访问和作用" class="headerlink" title="static synchronized 方法的多线程访问和作用"></a>static synchronized 方法的多线程访问和作用</h2><h2 id="同一个类里面两个synchronized方法，两个线程同时访问的问题"><a href="#同一个类里面两个synchronized方法，两个线程同时访问的问题" class="headerlink" title="同一个类里面两个synchronized方法，两个线程同时访问的问题"></a>同一个类里面两个synchronized方法，两个线程同时访问的问题</h2><h2 id="volatile的原理"><a href="#volatile的原理" class="headerlink" title="volatile的原理"></a>volatile的原理</h2><h2 id="谈谈volatile关键字的用法"><a href="#谈谈volatile关键字的用法" class="headerlink" title="谈谈volatile关键字的用法"></a>谈谈volatile关键字的用法</h2><h2 id="谈谈volatile关键字的作用"><a href="#谈谈volatile关键字的作用" class="headerlink" title="谈谈volatile关键字的作用"></a>谈谈volatile关键字的作用</h2><h2 id="谈谈NIO的理解"><a href="#谈谈NIO的理解" class="headerlink" title="谈谈NIO的理解"></a>谈谈NIO的理解</h2><h2 id="synchronized-和volatile-关键字的区别"><a href="#synchronized-和volatile-关键字的区别" class="headerlink" title="synchronized 和volatile 关键字的区别"></a>synchronized 和volatile 关键字的区别</h2><h2 id="synchronized与Lock的区别"><a href="#synchronized与Lock的区别" class="headerlink" title="synchronized与Lock的区别"></a>synchronized与Lock的区别</h2><h2 id="ReentrantLock-、synchronized和volatile比较"><a href="#ReentrantLock-、synchronized和volatile比较" class="headerlink" title="ReentrantLock 、synchronized和volatile比较"></a>ReentrantLock 、synchronized和volatile比较</h2><h2 id="ReentrantLock的内部实现"><a href="#ReentrantLock的内部实现" class="headerlink" title="ReentrantLock的内部实现"></a>ReentrantLock的内部实现</h2><h2 id="lock原理"><a href="#lock原理" class="headerlink" title="lock原理"></a>lock原理</h2><h2 id="死锁的四个必要条件？"><a href="#死锁的四个必要条件？" class="headerlink" title="死锁的四个必要条件？"></a>死锁的四个必要条件？</h2><h2 id="怎么避免死锁？"><a href="#怎么避免死锁？" class="headerlink" title="怎么避免死锁？"></a>怎么避免死锁？</h2><h2 id="对象锁和类锁是否会互相影响？"><a href="#对象锁和类锁是否会互相影响？" class="headerlink" title="对象锁和类锁是否会互相影响？"></a>对象锁和类锁是否会互相影响？</h2><h2 id="什么是线程池，如何使用"><a href="#什么是线程池，如何使用" class="headerlink" title="什么是线程池，如何使用?"></a>什么是线程池，如何使用?</h2><h2 id="Java的并发、多线程、线程模型"><a href="#Java的并发、多线程、线程模型" class="headerlink" title="Java的并发、多线程、线程模型"></a>Java的并发、多线程、线程模型</h2><h2 id="谈谈对多线程的理解"><a href="#谈谈对多线程的理解" class="headerlink" title="谈谈对多线程的理解"></a>谈谈对多线程的理解</h2><h2 id="多线程有什么要注意的问题？"><a href="#多线程有什么要注意的问题？" class="headerlink" title="多线程有什么要注意的问题？"></a>多线程有什么要注意的问题？</h2><h2 id="谈谈你对并发编程的理解并举例说明"><a href="#谈谈你对并发编程的理解并举例说明" class="headerlink" title="谈谈你对并发编程的理解并举例说明"></a>谈谈你对并发编程的理解并举例说明</h2><h2 id="谈谈你对多线程同步机制的理解？"><a href="#谈谈你对多线程同步机制的理解？" class="headerlink" title="谈谈你对多线程同步机制的理解？"></a>谈谈你对多线程同步机制的理解？</h2><h2 id="如何保证多线程读写文件的安全？"><a href="#如何保证多线程读写文件的安全？" class="headerlink" title="如何保证多线程读写文件的安全？"></a>如何保证多线程读写文件的安全？</h2><h2 id="多线程断点续传原理"><a href="#多线程断点续传原理" class="headerlink" title="多线程断点续传原理"></a>多线程断点续传原理</h2><h2 id="断点续传的实现"><a href="#断点续传的实现" class="headerlink" title="断点续传的实现"></a>断点续传的实现</h2><h2 id="并发编程有关知识点（这个是一般Android开发用的少的，所以建议多去看看）："><a href="#并发编程有关知识点（这个是一般Android开发用的少的，所以建议多去看看）：" class="headerlink" title="并发编程有关知识点（这个是一般Android开发用的少的，所以建议多去看看）："></a>并发编程有关知识点（这个是一般Android开发用的少的，所以建议多去看看）：</h2><h2 id="平时Android开发中对并发编程可以做得比较少，Thread这个类经常会用到，但是我们想提升自己的话，一定不能停留在表面，-我们也应该去了解一下java的关于线程相关的源码级别的东西。"><a href="#平时Android开发中对并发编程可以做得比较少，Thread这个类经常会用到，但是我们想提升自己的话，一定不能停留在表面，-我们也应该去了解一下java的关于线程相关的源码级别的东西。" class="headerlink" title="平时Android开发中对并发编程可以做得比较少，Thread这个类经常会用到，但是我们想提升自己的话，一定不能停留在表面，,我们也应该去了解一下java的关于线程相关的源码级别的东西。"></a>平时Android开发中对并发编程可以做得比较少，Thread这个类经常会用到，但是我们想提升自己的话，一定不能停留在表面，,我们也应该去了解一下java的关于线程相关的源码级别的东西。</h2><h1 id="学习的参考资料如下："><a href="#学习的参考资料如下：" class="headerlink" title="学习的参考资料如下："></a>学习的参考资料如下：</h1><h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p><a href="http://www.iteye.com/topic/806990">java线程安全总结</a><br><a href="http://ifeve.com/java-memory-model-0/">深入理解java内存模型系列文章</a></p>
<h2 id="线程状态："><a href="#线程状态：" class="headerlink" title="线程状态："></a>线程状态：</h2><p><a href="https://my.oschina.net/mingdongcheng/blog/139263">一张图让你看懂JAVA线程间的状态转换</a></p>
<h2 id="锁："><a href="#锁：" class="headerlink" title="锁："></a>锁：</h2><p><a href="http://blog.csdn.net/vking_wang/article/details/9952063">锁机制：synchronized、Lock、Condition</a><br><a href="http://wiki.jikexueyuan.com/project/java-concurrent/locks-in-java.html">Java 中的锁</a></p>
<h2 id="并发编程："><a href="#并发编程：" class="headerlink" title="并发编程："></a>并发编程：</h2><p><a href="http://www.cnblogs.com/dolphin0520/p/3920357.html">Java并发编程：Thread类的使用</a><br><a href="http://blog.51cto.com/lavasoft/27069">Java多线程编程总结</a><br><a href="https://www.jianshu.com/p/053943a425c3#">Java并发编程的总结与思考</a><br><a href="http://www.cnblogs.com/chenssy/p/4701027.html">Java并发编程实战—–synchronized</a><br><a href="http://www.infoq.com/cn/articles/ConcurrentHashMap#">深入分析ConcurrentHashMap</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>java</tag>
      </tags>
  </entry>
</search>
